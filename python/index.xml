<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pythons on Jeremy&#39;s blog</title>
    <link>https://jeremyyin.com/python/</link>
    <description>Recent content in Pythons on Jeremy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://jeremyyin.com/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>if True or if not True</title>
      <link>https://jeremyyin.com/python/2016-12-23-if-true-or-if-not-true/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jeremyyin.com/python/2016-12-23-if-true-or-if-not-true/</guid>
      <description>明天就是平安夜，我打算今晚啃个苹果。
以程序员的角色上岗工作已经正式3周过去了，这算是正式地公告一下。
放在几年前我从未想过我会正式地成为一名可以自己编程写代码的人，可是在这几年的工作中逐渐地接触到一些事务，使得我认为在未来的日子里，不会自己写几行程序代码的人们总是会有一些很难过的坎儿。
所以，无论将来如何变化，我先去坑自己一把，把编程这事儿彻底地扶正了来做，再也不是什么随便搞搞就行的事情了。
但是说回来这事儿还真不是会不会程序语言语法这么简单的事情，学会了使用写法只是冰山冒个尖儿，下面水很深，路很长，坑更是多不胜数，我只能寄希望于天兵天将们不要懒惰。
这儿说，关于思维方式。
或许是我开始学习Python的时候，就接触到的都是：
如果True，就去做什么，否则，就做点什么。
然而今天深入到别人的项目中之后，基本上都是：
如果不是True，就做点什么，否则，就去做什么。
这使得我很困惑啊，脑子现在还晕。
就这么绕啊绕，不知道死了多少脑细胞，反正也没法具体数，你就给个超级大的数字就好了。
所以，啃个苹果清一清神儿吧。
祝平安夜幸福，祝圣诞节快乐，各位！
新年见！</description>
    </item>
    
    <item>
      <title>努力投身 Python 3 的怀抱</title>
      <link>https://jeremyyin.com/python/2017-09-02-%E5%8A%AA%E5%8A%9B%E6%8A%95%E8%BA%AB-python-3-%E7%9A%84%E6%80%80%E6%8A%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jeremyyin.com/python/2017-09-02-%E5%8A%AA%E5%8A%9B%E6%8A%95%E8%BA%AB-python-3-%E7%9A%84%E6%80%80%E6%8A%B1/</guid>
      <description>15 年开始学习 Python 的时候，看遍了大家关于应该选择 Python 2 还是 Python 3 的讨论和争执，还有，妥协。
按照我买电子产品“买新不买旧，买好不买差”的原则，我毅然决定先从了 Python 3 再说。
是的，争执无意义，行动才是根本。
后来，进了新公司，放眼望去是 Python 2 的世界，曾有想法切换，却始终被几个函数限制，没能彻底实现下来。
昨日，开了个新项目，心思又动起来。
今日，将原来的函数研究一番，可以连通了。
以后的新项目，就走向 Python 3 吧。
未来，是它的。
&amp;ndash;
今年 Python 这门程序语言终于冲上了头牌，在机器学习、大数据分析、人工智能等几个领域热火朝天。
然而，现实情况是无论外面如何热火，却没有当初那种决然冲进去弄一把再看的动力，说到底，还是没有实际的目标可以拿来玩耍。
先做做 Web 也好吧，是时机未到。
想想呢，我们确实处在一个最好的时代，Python 3 发展了好多年，相关的配套也都成熟，开箱可用，拿来就用，上手简单，做事容易，实在是最好的时代，连我这样贸贸然闯进来的也能无所畏惧地动手。
不过这样被如此美好的时代所惯坏的开发者，很多时候，真是懒得动手，一想着有点复杂操作的就觉得痛苦，凡是步骤超过 5 步的操作都觉得烦操，最好是一行代码或者命令就能操作起一切。
是，喜欢 Docker。
一行 docker-compose up -d ，或者是 docker-compose down ，甚至是 docker-compose scale app=8 ，直接就撑起整个世界的感觉，真是极好不过了。停止与重新开启的时间不过几秒钟，真是让人很喜欢的东西。
可惜了，它和 Windows 相处还不怎么友好，这又是个痛苦的面对，自己 Mac 开发玩可以很爽，可运行产品的环境竟然如此糟糕，不能忍，但又没辙。
是开发者，忍受得了千万种折磨。
同时，也是用户，喜欢简洁明了的操作体验。
不知道这世界明天会走得多快，没有什么是理所当然。</description>
    </item>
    
    <item>
      <title>给一个列表去重复却又要保留顺序</title>
      <link>https://jeremyyin.com/python/2016-06-28-%E7%BB%99%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%8D%B4%E5%8F%88%E8%A6%81%E4%BF%9D%E7%95%99%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jeremyyin.com/python/2016-06-28-%E7%BB%99%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%8D%B4%E5%8F%88%E8%A6%81%E4%BF%9D%E7%95%99%E9%A1%BA%E5%BA%8F/</guid>
      <description>collections.OrderedDict.fromkeys(list).keys() 在python中，有时候有需要用到保留原始顺序而又能去掉重复的列表。
而在python自身的基本数据结构里面，给list去除重复可以用set(list)来进行操作而得到一个没有重复的set集合，但是这样也就把list元素原有的先后出现的顺序而被打乱了，打的乱七八糟的。
会写pytho的也可能会找到很多的解决办法，有容易的有复杂的有高级的。
我的方法 在python的collections包里面有个数据结构叫OrderedDict，有序字典。
字典的key有个特性是不会重复，python默认的字典的key也是无序的，这是由它本身的特性决定的，但是有人结合了list的特性，制造了这个有序字典的数据结构，它输出的key和value都是有序的。
所以利用它的这些特性，这样理论上就会很容易就能得到有序的没有重复的list了。
import collections datalist = [&#39;1&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;, &#39;2&#39;, &#39;4&#39;] newlist = collections.OrderedDict.fromkeys(datalist).keys() print(newlist) [&#39;1&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;]  这样就能得到一个保留元素第一次出现的先后顺序又去除了重复元素的list了。一般用来给人查看或者是显示操作结果的时候，是对人很友好的。
好了，这里其实是第一次正经测试markdown语法来写文章的内容，目前看起来貌似还蛮美观的吭。</description>
    </item>
    
    <item>
      <title>造个轮子</title>
      <link>https://jeremyyin.com/python/2017-06-14-%E9%80%A0%E4%B8%AA%E8%BD%AE%E5%AD%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jeremyyin.com/python/2017-06-14-%E9%80%A0%E4%B8%AA%E8%BD%AE%E5%AD%90/</guid>
      <description>技术，是个好东西。
有能力利用技术造出一些有用的东西，也是再也欣喜不过了。
我们都知道造房子有点难度，构建高楼大厦就更加有技术难度，从设计到施工，没任何人全能精通。造汽车就也难了，虽然也是从设计到制造，可知识又是数不过来的多，更不用说制造经验和制造水平。
能清晰解释出差速器原理的，也是不错了。
可是，当轮到复杂度同样不比造房子造汽车底多少，有时候甚至更为复杂的编程领域时，为什么大家就不觉得这有什么难度了呢？
 我觉得这个没那么复杂，你这样，这样，然后这样……，不就可以了嘛，我认为理论上是肯定可以的，你就照我说的做，到时候看到问题我再告诉你改哪里……
我不管技术上怎么实现哈，我就只说我的需求……
我想要你实现我把这个处理完的文件在手机上就能直接发给别人，这样我就不用还去开电脑了，晚上谁还不是想躺床上拿手机点几下就把活干完的……
你这个一两天肯定是做不出来嘛，半个月你能不能做出来……
 我觉着我要是能半个月定制化做个订单系统出来（仅仅后台 API ），我也觉得我完全能配得上 professional 这个词了。
可惜，认清现实吧。
一周，也就结识了个多级分类。
至于，造一个多级分类到底有何难度，我也无法解释清楚。
至少，这并不是一棵树而已。
好了，多级分类搞得定，后面也还是好说的。
未来，这个简单实现的多级分类看要不要开源。
&amp;ndash;
人说，不要重复造轮子。
可惜真相是，先不说没有合适的轮子可用，假使有，那么也得懂的轮子的一些些细节，才能正常使用吧。
见过给桑塔纳上三一重工的轮子的么？
好了，自己的轮子能用了，收一收，再这样下去，女朋友都该跑路了。</description>
    </item>
    
  </channel>
</rss>