[
    {
        "content": "需求是这么来的：根据参数执行查询，然后生成 Excel 表供下载，简单说就是查询并导出。\n一种思路是根据参数动态生成 select 查询对象，然后执行拿到结果，大概是这样：\n... sql_select = select(columns).select_from(join_obj).where(whereclause).offset(offset).limit(limit).order_by(order_by) result = session.execute(sql_select) count = result.rowcount rows = [dict(row) for row in result.fetchall()] 然后拿到 rows 就可以去该做什么处理就做什么处理了，如果要生存 Excel 表，就可以使用 XlsxWriter 这个工具去写表文件，反正就是对 rows 开个 for 循环就是了。\n不过呢，还有没有更好的办法？\n假设如果我要对 rows 的数据要做些高级处理，而不是开个 for 循环。毕竟如果是处理数据的话，Pandas 这个工具在思维方式和代码组织上比 for 循环要更利于思考和维护，而同时我们也知道 Pandas 也能直接输出 Excel 文件，那么是否可以用上它？\n按常规，查询得到 rows，然后再生成一个 df，对 df 进行一些处理后再去输出 Excel，甚至同时还要把修改后的数据输出为新的 rows，那么这里：查询得到结果、把结果生成 df 这两个步骤涉及到两步数据转化，理论上来说肯定是有一些消耗的，如果是在 API 服务上使用，则需要考虑性能问题，能少一步就少一步。\n那么，是否可以一步到位呢？直接查询结果就得到 df，而不是自行再多做一步中转处理。\nPandas 是可以直接 read_sql 的，具体说明如下：\ndef read_sql(sql, con, index_col=None, coerce_float=True, params=None, parse_dates=None, columns=None, chunksize=None): &#34;&#34;&#34; Read SQL query or database table into a DataFrame. Parameters ---------- sql : string SQL query or SQLAlchemy Selectable (select or text object) to be executed, or database table name. con : SQLAlchemy connectable(engine/connection) or database string URI or DBAPI2 connection (fallback mode) Using SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported. 所以 Pandas 可以接受 raw sql 也可以接受 SQLAlchemy Selectable 对象。\n这就好说了，如果把做好的的 sql_select 不是传给 session.execute 而是传给 pd.read_sql，这事不就实现了。\nimport pandas as pd df = pd.read_sql(sql_select, con=self.get_engine()) logger.debug(df) 当然，pd 的 con 参数接受的不是一个 session 实例，而是一个 engine，也就是创建 session 一步的那个 engine 参数。\n同时，如果需要调试查看 sql 语句和参数，可以多做点工作：\nfrom sqlalchemy.dialects import mysql import pandas as pd sql_raw = sql_select.compile(dialect=mysql.dialect()) params = sql_select.compile(dialect=mysql.dialect()).params logger.debug(sql_raw) logger.debug(params) df = pd.read_sql(sql_select, con=self.get_engine()) logger.debug(df) 当然其实也可以把 sql_raw 和 params 分开传给 pd.read_sql，但貌似也没这个必要性了。\n而后就可以对 df 做处理，以及最终可以调用 df.to_excel(&lsquo;./output/test.xlsx&rsquo;, index=False) 生成 Excel 表格文件，这里加了个 index=False 是为了不让默认的行数索引写入表格。\n当然也可以继续调用 df.to_dict(orient=&lsquo;records&rsquo;) 生成 rows 来用，或是直接 df.to_json(orient=&lsquo;records&rsquo;) 生成 json 输出了。\n",
        "date": 1540857600,
        "objectID": "51008c97fd208a4aca944ededc6723f0",
        "relpermalink": "/note/2018-10-30-2042/",
        "section": "note",
        "title": "使用 Pandas 实现动态查询及处理数据并导出 Excel 文件",
        "size": 4590
    },
    {
        "content": "搞定了 select columns 的动态列查询，接着就该来搞定 where and or 的动态参数化查询了。\n猛一想，where 这部分的参数化查询，如果我用 pymysql 的 cursor，或者用 SQLAlchemy 的 engine 或者 session 直接调用 execute 执行文本语句，也是可以给语句的 where 参数动态传参的呀？\n不，我说的更进一步的：除了参数可以动态传入，我想要 where 语句也要动态改变，即动态条件查询。\n可能要是没辙的话 大多数都跑去冒着 sql 注入的危险，启用文本格式化工具来写一堆条件来动态拼接语句了。\n不说最后拼出来的对不对，开发效率、调试速度，总要顾及一下吧？\n之前的动态列查询使用了 SQLAlchemy Core 里面 select 工具，通过可以定义单个 column 的办法动态处理得到供 select 使用的 columns，实现无论你要多少列，要什么不要什么，都可以通过列名称参数进行动态地处理得到，具体再多去写一些实际需求，应该就会熟练上手了。\n而 where 的动态化，你基本也想到了，还是会在 select 这个工具下面来进行。\n看官方的写法：\ns = select([users, addresses]).where(users.c.id == addresses.c.user_id) 不过目前写后台 API 程序的话，基本上可能会这么写：\ns = select([users, addresses]).where(users.c[&#39;id&#39;] == addresses.c[&#39;user_id&#39;]) 然后再把这里的字符根据情况使用变量名替换掉。\n上面的 where 只有一个条件，如果有多个条件，要用到连接符了，同时也有提供专门的连接词来处理：\nfrom sqlalchemy.sql import and_, or_, not_ and_( users.c[&#39;name&#39;].like(&#39;j%&#39;), users.c[&#39;id&#39;] == addresses.c[&#39;user_id&#39;], or_( addresses.c[&#39;email_address&#39;] == &#39;wendy@aol.com&#39;, addresses.c[&#39;email_address&#39;] == &#39;jack@yahoo.com&#39; ), not_(users.c[&#39;id&#39;] &gt; 5) ) 相对应的三个连接符就是：&amp;、|、~\n不过目前来看，我会更喜欢连接词方式，为啥，因为要动态化呀，嗯？没看出来咋搞？这样：\nclauses = [] clauses.append(users.c[&#39;name&#39;].like(&#39;j%&#39;)) clauses.append(users.c[&#39;id&#39;] == addresses.c[&#39;user_id&#39;]) s = select([users, addresses]).where(and_(*clauses)) 重点就在这个星号 *，标准的 *args 赋值模式，对吧。这样你就可以自由地去操作 clauses 这个列表了，根据不同的情况，动态地往里面加任何可以加的查询条件，甚至嵌套几层 and_ , or_ , not_ 进去都是可以的。\n好了，基本就这样了，更多细节，其实要自己真的去尝试写了才会有概念，这里仅是做个笔记。\n",
        "date": 1540684800,
        "objectID": "ead94924538d6d5925bd3480f9d8893e",
        "relpermalink": "/note/2018-10-28-2102/",
        "section": "note",
        "title": "dynamically parameter passing in sql where query best practices",
        "size": 3128
    },
    {
        "content": "你看到了，动态列查询、动态条件查询，两大动态查询都使用 使用 SQLAlchemy Core 的 select 工具来进行实现，发现没有，要想使用 select，那就必须要有表对象，有了表对象，它才能帮你实现各种动态查询条件语句的生成，没有这些表对象为基础，那可就巧妇难为无米之炊了。\n那么，是否就一定要把这些表对象一个一个，一列一列，完完整整地重新敲出来呢？\n我一开始就是这么干的。\n等我干了几个表，发现太折磨人了。如果建表是自己来，那么一定会去写这些个 Table 的定义，但是如果是接手了一个现有的数据库呢？全部重新手打实现，真的就是要死要活了。\n作为程序员思维者，Python 生态已经很成熟了吧，SQLAlchemy 如此强大，是否可以帮忙从数据库里面读取这些 Table 信息出来？\n结果真的是可以的：\nfrom sqlalchemy import create_engine from sqlalchemy import MetaData db_uri = &#39;mysql+pymysql://username:password@localhost:3306/test&#39; engine = create_engine(db_uri) metadata = MetaData() metadata.reflect(bind=engine) print(metadata.tables) # immutabledict({&#39;address&#39;: Table(&#39;address&#39;, MetaData(bind=None), Column(&#39;ID&#39;, ... 看到输出这么一串，简直想哭啊。\n好了，想要怎么用就不用我多说了，有了这个字典，想怎么用怎么用去。\n",
        "date": 1540684800,
        "objectID": "569bbde1fac88c4f7be48596c97a9076",
        "relpermalink": "/note/2018-10-28-2216/",
        "section": "note",
        "title": "使用 SQLAlchemy Core 的 select，可是没有定义表对象怎么办",
        "size": 1598
    },
    {
        "content": "难免要用到连表查询，这时候如果一个表不止用一次，或一个列名可能产生冲突，就需要用到别名，同时表别名还能优化查询语句的长度和可读性，SQL 里面的 SELECT，则会用到 AS 或者不用 as 就直接跟在项目后面即可。\n那在 SQLAlchemy select 中要怎么实现呢：\n不多说，上例子：\n# 表别名：select * from my_customer_table as customer customer = my_customer_table.alias(&#39;customer&#39;) # 列别名 select user.name as username from user columns = [ customer, user.c[&#39;name&#39;].label(&#39;username&#39;) ] 这样就可以了。\n",
        "date": 1540684800,
        "objectID": "0a976733e687b8cd2a4f5c22e0319df6",
        "relpermalink": "/note/2018-10-28-2249/",
        "section": "note",
        "title": "SQLAlchemy select 中的表别名、列别名",
        "size": 832
    },
    {
        "content": "使用 mysql 等类型的关系型数据库，最大的一个痛点之一就是写查询语句了，其中一个需求就是动态列查询，网络上的文章千百万，问题和回答也千百万，靠谱不靠谱，对于搜这个问题的人，应该都难分辨。\n对于做数据分析，可能不太会有这个需求，大多数情况下，是在构建 API 接口的时候。\n如果业务功能需求简单，不常变化，或是 API 接口功能设计上不用支持各种类型的动态列查询，那也罢了。\n但是，如果需求百般变化，一个接口要是不支持动态列查询，又如何应对呢？\n比如这个：具体要返回哪些数据列，前端要传参，后台要判断是否应该返回。\n跟在 select 语句后面、table 名称前面的这段内容：列名称，就是要动态控制的地方。\n然而，虽然 sql 语句是文本，初看貌似可以通过动态生成文本的方式来实现，这真的可行么？\n答案自然是不行的，为啥？sql 注入（SQL injection）希望你了解下。\npymysql 支持参数化查询，%s 与 %(name)s，是否可以用参数化查询来控制呢？比如这样：\nparams = {&#39;limit&#39;: 10, &#39;columns&#39;: &#39;, &#39;.join([&#39;id&#39;, &#39;name&#39;])} sql = &#39;select %(columns)sfrom test limit %(limit)s&#39; cursor.execute(sql, params) 测试过，也不行的，你也可以试试看。\n所以，动态列查询，到底要如何解决呢？\n有人说，这样可能你只能用 ORM 工具来解决了，其实这个方向倒是没错的，毕竟要是自己真的有能力处理，可能最终写出来的，已然跟 ORM 没差多少了。\nSQLAlchemy 我是知道一定可以做到的，但是，一定要用 ORM 么，一定要写 Model 么？更何况 SQLAlchemy 的 ORM 模式又要如何进行动态列查询目前也还没找到答案，以及数据序列化又是另外一个问题，文档可能太厚了，而教程又太精炼，且还分散在各处。\n终于，我想到了 Pandas，这个东西支持直接就从 sql 数据库读取数据，而且还支持选择想要列，或许可以看看它是如何实现的，从 pd.read_sql() 开始往里翻，让我找到了这个：\ndef read(self, coerce_float=True, parse_dates=None, columns=None, chunksize=None): if columns is not None and len(columns) &gt; 0: from sqlalchemy import select cols = [self.table.c[n] for n in columns] if self.index is not None: [cols.insert(0, self.table.c[idx]) for idx in self.index[::-1]] sql_select = select(cols) else: sql_select = self.table.select() result = self.pd_sql.execute(sql_select) column_names = result.keys() if chunksize is not None: return self._query_iterator(result, chunksize, column_names, coerce_float=coerce_float, parse_dates=parse_dates) else: data = result.fetchall() self.frame = DataFrame.from_records( data, columns=column_names, coerce_float=coerce_float) self._harmonize_columns(parse_dates=parse_dates) if self.index is not None: self.frame.set_index(self.index, inplace=True) return self.frame 今天的重点在这一部分：\nif columns is not None and len(columns) &gt; 0: from sqlalchemy import select cols = [self.table.c[n] for n in columns] if self.index is not None: [cols.insert(0, self.table.c[idx]) for idx in self.index[::-1]] sql_select = select(cols) else: sql_select = self.table.select() result = self.pd_sql.execute(sql_select) column_names = result.keys() 赤裸裸地用着 sqlalchemy 的 select ，这是 SQLAlchemy Core 里面的东西，号称 No ORM Required。SQLAlchemy ORM 也是基于 Core 的。\n虽然 pandas 在文档中明确地指出：\n&#39;&#39;&#39; columns: list, default: None List of column names to select from sql table (only used when reading a table). &#39;&#39;&#39; 意思就是只能在读取一个 table 的时候才能使用 columns 参数。\n不过这个是 pandas 所建立的高层逻辑，而所使用的 select 底层其实支持更丰富的查询方法，具体可以参考 Selecting 教程。\n核心看这句：cols = [self.table.c[n] for n in columns]，利用 table.c[n] 这个方法从列名称构建了列查询，实现了动态列查询的功能。\n为啥之前看教程时候没想到这个，因为看到的都是这么写的：table.c.name，而不是 table.c[name]，根本没想到可以往字符变量上去靠，现在想想，其实把字符赋值给一个变量名称，然后再使用，也就是一样的效果。脑袋没转过来，毕竟思维定势了。\n不过依然还是有个前提，表对象是要存在的，字段名也是要存在的，否则就会报错的。\n中间的这个 c，其实就是 columns : An alias for the columns attribute. 它的类型是 ImmutableColumnCollection，简单认为是一个只读的字典就好了。\n如果你有一个 user 表，列名称叫 &lsquo;username&rsquo;，\ncol = user.c[&#39;username&#39;] 知道这个方法，接下来基本上就看你自由发挥了。关于表和列的更深入的知识，请参考 SQLAlchemy 的教程说明和 API 说明，能不能挖出宝来就自己了，我是真的会容易看晕：\n Define and Create Tables\n Column, Table, MetaData API\n Column Elements and Expressions\n  也尝试构建使用多个表的动态列查询：\ncolumns_user = [&#39;id&#39;, &#39;name&#39;] columns_order = [&#39;id&#39;, &#39;amount&#39;] cols_user = [user.c[n] for n in columns_user] cols_order = [order.c[n] for n in columns_order] sql_select = select(cols_user + cols_order).limit(10) 又或者可以是这样：\ntables = {&#39;user&#39;: user, &#39;order&#39;: order} columns = [&#39;user.id&#39;, &#39;user.name&#39;, &#39;order.id&#39;, &#39;order.amount&#39;] cols = [] for n in columns: t_name, c_name = n.split(&#39;.&#39;) cols.append(tables.get(t_name).c[c_name]) sql_select = select(cols).limit(10) 至此，还没有用到 ORM 层的东西，唯独需要预先做的事情的就是去定义表结构对象。\n",
        "date": 1540512000,
        "objectID": "3512a75b2996cf781bd1ab7c36fda698",
        "relpermalink": "/note/2018-10-26-2133/",
        "section": "note",
        "title": "dynamically select columns in sql query best practices",
        "size": 7586
    },
    {
        "content": "pymysql 执行 sql 操作的最主要一个方法就是：cursor.execute(sql, *args)\n它给了个这样的例子：\nimport pymysql.cursors # Connect to the database connection = pymysql.connect(host=&#39;localhost&#39;, user=&#39;user&#39;, password=&#39;passwd&#39;, db=&#39;db&#39;, charset=&#39;utf8mb4&#39;, cursorclass=pymysql.cursors.DictCursor) try: with connection.cursor() as cursor: # Create a new record sql = &#34;INSERT INTO `users` (`email`, `password`) VALUES (%s, %s)&#34; cursor.execute(sql, (&#39;webmaster@python.org&#39;, &#39;very-secret&#39;)) # connection is not autocommit by default. So you must commit to save # your changes. connection.commit() with connection.cursor() as cursor: # Read a single record sql = &#34;SELECT `id`, `password` FROM `users` WHERE `email`=%s&#34; cursor.execute(sql, (&#39;webmaster@python.org&#39;,)) result = cursor.fetchone() print(result) finally: connection.close() 语句写好了，里面可能有很多占位符 %s，但是数据参数，如果有很多，又要一个一个定好位置组成 tuple 再给它么？长期这么干最后总会心累的，能不能直接传 dict 给它呢？\n答案当然是可以的，有人在 stackoverflow 上也问了这个问题，答案中还解答了关于数据库驱动的 paramstyle 问题，因为支持什么样的模式，完全看数据库驱动的实现方式了。\n %s 这种占位符的，叫 format 模式，一般可以使用 %(name)s 这种格式来使用字典参数 ? 这种占位符的，叫 qmark 模式，一般会使用 :name 这种格式来使用字典参数，SQLAlchemy 看起来就是用的这种  还有一种叫 numeric 模式的，具体可以看下这个 paramstyle 的说明\n查询数据库驱动支持什么样的，这里只看下 pymysql：\nIn[21]: import pymysql In[22]: pymysql.paramstyle Out[22]: &#39;pyformat&#39; 以及，pymysql 也在 execute 文档中明确提到这么一句：\nIf args is a list or tuple, %s can be used as a placeholder in the query. If args is a dict, %(name)s can be used as a placeholder in the query.\n这样，就能确定可以使用 %(name)s 这种格式来使用字典参数了：\nparams = {&#39;limit&#39;: 10} sql = &#39;select * from test limit %(limit)s&#39; cursor.execute(sql, params)",
        "date": 1540425600,
        "objectID": "2f9464b927876a051048ee59886bc64e",
        "relpermalink": "/note/2018-10-25-2121/",
        "section": "note",
        "title": "pymysql: 给 sql 语句传递字典参数",
        "size": 3364
    },
    {
        "content": "连续两期吐槽 Traefik，是确实有它可吐槽的点在，虽然将来我可能也还会用它，毕竟特性真的非常契合需求，但要说我自己能有信心上线，现在还不是时候，项目是好，可文档也要写好点吧，别说 Docs for Humans，逻辑结构和思路要清晰，别要找找不到，甚至不明不白和内容有陈旧感。\n目前最终并没有启用 Traefik 的方案，而是启用了 nginx-proxy 这个基于 docker-gen 的方案，并且同时还有人帮忙弄了配套的 Let&rsquo;s Encrypt 工具，就成熟度来说，已经非常可以了。\n经过一段时间的熟悉、测试、修改，并最终建立自己喜欢的 docker-compose 编排文件，现在已经在我的一些生产级项目上开始正式运行了。\n到目前为止，用到的东西，几乎所有类别都已经 Docker 化了。\n Web 动态应用，比如基于 Tornado 的 Web 和 API，使用 Python 官方镜像进行 Docker 化，到底 2 和 3 怎么处理，甚至 2.7.14 和 2.7.15 或是 3.6 还是 3.7 这样严重困扰开发和运行的问题都不复存在。 定时任务脚本，原先跑在机器系统上的 cron 或者是 Windows 的计划任务，基于 Python 镜像使用 APScheduler 进行 Docker 化，利用 subprocess.run 完成无缝迁移，不需要修改任何原先已有代码，再也不用去敲 crontab -e 和 crontab -l 去修改和查看任务配置，数据都在代码里，配置也不会丢，重新换机器直接 docker-compose 起容器即可。关于 APScheduler，你也可以选其它的工具进行替代，因为我是 Python，而 Python 里面我一番测试下来又觉得它最好，虽然会稍微复杂点。 爬虫及自动化，简单脚本上面说了，复杂的爬虫服务，批量部署和灵活调用，以及数据监控和自定义任务，还有需要用到自动化工具的，比如浏览器渲染，都已经 Docker 化了。 静态文件服务，这个 nginx 直接拿来用，把文件做成服务供其它服务去使用，这又比把文件的绝对路径挂载到别的服务上要好很多，我也是这几天才猛然想通，要笑哭。毕竟很多时候这些文件并不是直接弄出来的，而是要利用其它工具生成的，比较适合独立项目，而不是跟其它混放一起，而挂载又会影响别的项目的一些配置。 数据库，这个真的要，数据库装到系统里面你还想升级？想都别想，但是到了 Docker 这就是改个标签的事情。不过有些大版本兼容性还是要自己看清楚，一般都是会有说明的，而且即使不行，退回去也极其简单啊，你说是不是。另外，性能不是问题。 HTTPS，迟迟有些东西不敢随便动手的一个原因就是它，当初设置 https 的时候，Let&rsquo;s Encrypt，看了很久才配置完成，然后又多次等很久去确认配置 OK（确认确实有在更新），现在把它也 Docker 化了，真的就轻松极了。能理解对标 nginx 的那些，为啥要把这个作为主要卖点挂出来了。  暂时记录这么多，总之一点，能 Docker 化的一定想方设法 Docker 化，即使要曲线救国都行。\n",
        "date": 1540252800,
        "objectID": "bde751e7bca6253ae81e5725bed319aa",
        "relpermalink": "/note/2018-10-23-2226/",
        "section": "note",
        "title": "nginx-proxy 与 Let's Encrypt",
        "size": 2728
    },
    {
        "content": "尝试去测试 Envoy，甚至还去看了 Istio。\nEnvoy 跑了个 front-proxy 的 demo，Istio 也尝试了下，起了一地容器，可惜想看看管理页面，失败。\n这两货，都是所谓云原生平台工具，想了想，k8s 都还没折腾好呢，这俩货确实有点太重了。\n又回去继续试试 Traefik，这次果然心平气和了很多。开台机器，设置域名，启动容器，打开页面，竟然，通了。\n但是，到此，并不表示对它的好感有增，原先吐槽的点依然还是存在。通是通了，但是还有很多东西没着落：https 在哪，配置文件到底要不要自定义，默认的配置文件在哪儿……即使进去容器里面，也没找到什么东西，命令行的说明也是云里雾里（根本没有）\n再想着瞅一眼 nginx-proxy，还是试试吧。\n下载，docker-compose up -d 走起，看到日志说正在干嘛了，心里放心了很多，不像 Traefik 默认啥信息都没有，空空白白的一片黑，遇到连接错误也不知道为啥。\n比较下，感觉 nginx-proxy 还是可以拿来仔细研究看看，实在不行，前面还可以继续套一层普通 nginx 完成其它事情，不是么。\nk8s 可能还要一段时间才能成熟到我等非资深用户也能放心使用，新东西，还是需要时间等待。\n基于 k8s 的相关东西，可能就更需要时间了。\nnginx，跑了可是很多年了，才成熟到我们非资深用户也可以简简单单就稳定地跑起来。\n基础工具选好搭好，我们放开手去写业务逻辑。\n",
        "date": 1539820800,
        "objectID": "0120e0e400d4d09c775adde8e0698ae3",
        "relpermalink": "/note/2018-10-18-2127/",
        "section": "note",
        "title": "Traefik 与 nginx-proxy",
        "size": 1318
    },
    {
        "content": "用上了 Docker，然后就有了一堆容器。Nginx 也是容器，一般拿它作为访问入口，其它容器在它的背后，这就是反向代理 Reverse Proxy。\nNginx 够不够好，够好，而且非常好。但是，容器要 scale，或者容器出现变动，结果它也不得不去更新配置并重启，还要额外再费力气去维护它，痛。\n所以就去找新东西。\n要说特性，Traefik 蛮符合要求的，本机跑个小 demo，觉得还行，以为可以上手用。\n结果嘛，文档乱七八糟，在线开了机器，备好域名，跟着文档做这多次都做不出可用的配置来。\n疯了。\n我是对很多东西理解不到，但不至于这么蠢。\n耐心也不是这么被磨灭的。\n放弃好了。\n还以为，这是个非商业化的产品，所以文档及其难看，再一看，其实是个法国的商业公司。\n好吧，难为你了。\n下次吧，或者，继续再找新的更好的可替代品。\n还有 nginx-proxy，但是看到带 nginx 不太想折腾。\n还有 Envoy，这是个什么？\n",
        "date": 1539734400,
        "objectID": "8dd9b912d3a5c9ca05cda7ccbc951fd1",
        "relpermalink": "/note/2018-10-17-2125/",
        "section": "note",
        "title": "折腾与吐槽 Traefik",
        "size": 902
    },
    {
        "content": "Python 有许许多多的自带库和第三方库，如果遇到一个新需求点，分析到代码层实现的时候，除去自有的控制逻辑实现之外，对于单个通用功能点的实现，基本上第一件事是去寻找是否存在可用的库可以拿来直接用的，或者是可以学习其实现逻辑和一些理念。\n与 awesome python 不同的是，这里目前只列自己用的，不求大而全，只是稍微记录下自己的一些理解，暂时也不做什么分类了，写到哪里是哪里。\n APScheduler ，用来运行定时脚本任务。 tornado ，用来搭 API 和 网站的 Web 框架，异步非阻塞。 requests ，用来发 http(s) 请求的，目前是同步阻塞型的。 bleach ，用来过滤 html 里面的标签。 redis ，是 Redis 的连接工具。 pymongo ，是 MongoDB 的连接工具。 beautifulsoup4 ，解析 html/xml 内容的工具，记得选择 lxml 用。  ",
        "date": 1538006400,
        "objectID": "b62c5f688864a4780e278fa7d0fa5d39",
        "relpermalink": "/note/2018-09-27-2123/",
        "section": "note",
        "title": "自己在用的一些 Python 库",
        "size": 902
    },
    {
        "content": "最早我是在 Windows 上面开始学习和开发 Python 程序的，最开始是写些脚本来定时帮我更新一些数据，后来觉得需要有个地方来让多人共享查看这些数据，就进一步进行了 Web 开发。\n关于如何定时运行脚本，在 Windows 上面是有个叫“计划任务”的程序，当时就在它里面设置了一系列的运行任务，它会定时帮你启动程序脚本，如果使用的是 python.exe 启动，会有黑色命令行窗口，如果是使用 pythonw.exe 启动，则不会出现窗口，但是它确实在运行，你可以在任务管理器当中看到进程的存在。而我觉得还是需要观察下它到底运行的如何的，所以一般还是会使用带窗口的，虽然有时候还正在做着事情，忽然就弹出几个窗口来，后来习惯了也就觉得没啥影响了。\n后来，开始在 Linux 上面来运行程序。在这个系统平台上面，可就没有什么可操作的界面给你用了，都是命令、命令、还是命令。\n如果要在 Linux 上面定时运行任务，基本上会选择 cron 这个工具，不过它的命令其实又是 crontab。使用 crontab -l 列出当前用户已设置的任务列表，使用 crontab -e 调用默认编辑器对任务列表进行编辑，编辑器要是没有特别设置的话一般都是 vi 这个，初次接触的话可能要先去研究下怎么进入和退出编辑状态以及如何保存文件并退出。\n虽然可能已经有很多针对 cron 的改进款替代品，不过一般也没谁特地再去折腾自己，简单纯粹，凑合用了。\n由于 Linux 目前这个时间点能开箱直接让你用上 Python 3 的可能性几乎为零，所以一般情况下还需要额外再自己编译安装下 Python 3，特别是当你是非 root 账户的情况下，这又多了一次折腾了，多数情况下，你可能会遇到提示某个库缺失的情况，那就缺啥装啥，再来一次，反复折腾几次，就应该差不多了。\n正常情况下，机器要是没遇到啥特别的情况，基本上运行环境就这样了，没谁会再冒着把环境搞砸的风险而手痒去维护更新升级，更不用说大概率是会让已经在运行的任务要么停止运行一段时间或者由于测试而产生重复运行导致数据不符合预设要求的情况。\n以上基本上是绝大多数情况下的常规选择路径了，没啥特别情况的话，到此基本差不多了。\n不过，其实这样的选择在很长一段时间内也不会有什么问题，只是总还是觉得有点麻烦，开启一批脚本并使得它们确认正常运行，还是需要花上蛮长一段时间的，毕竟当中有些步骤是只有当你去正式动手操作了才会知道具体会遇到什么问题，等搜索完相关信息并执行完解决方案，实际已经敲打了不少命令，然而这些命令，并不会自然地留下任何文件记录，除非你操作一步又额外再去复制内容记录一下，不过大多数情况下，都是不会有心情这么干的，何况记录的还不一定正确和完整。假设再来一次新机设定，也依然还是重复这个路径，当然，有运维的就另当别论，不过，即使是运维，也不会喜欢行一步看一步，并重复很多次。\n所以，其实问题还是有很多。\nDocker 从两三年前一飞冲天，坊间的互联网上到处都在谈论关于容器的事情，给人感觉但凡是个程序员都会设法尝试下容器并写出几篇“容器入门“的文章，不过容器的发展速度用日新月异来形容简直不为过分，留下在互联网上的一句句 docker pull 和 docker build 还有 docker run 并携带一串串长长的参数，可能并未给人留下多好的印象。毕竟，我们真的会那么喜欢命令么？并不，超过 3 个字符的命令我们都会设法 alias 为 2 个字符，更不用说那么一串几百个字符还带换行符的命令了。\n还好，有 docker-compose 可以解决下，把命令都变成 yml 文件留下来吧，这样还能进入 git 进行版本控制，对我来说，只要有 docker-compose up -d 和 docker-compose down 就可以了。当然现在，更多的是 docker-compose -f docker-compose.dev.yml up -d 和 docker-compose -f docker-compose.dev.yml down，以及 docker-compose -f docker-compose.prod.yml up -d 和 docker-compose -f docker-compose.prod.yml down 这样的两套几乎仅有一处文件差异的启动和停止命令。\nWeb 服务程序反而是最开始启用 Docker 来运行的，而直到现在才认为找到了正确并合适的方法来在 Docker 中运行定时任务程序。\n曾尝试过照旧使用 cron 在容器当中启动运行定时任务程序，虽然在本机 macOS 上的 Docker 中是基本没啥问题，可是到了 Docker for Linux 那边，就绝对不会一开始就让你正常运行的，毕竟，除了你要真的搞明白 cron 任务列表的更新原理之外，还有一道文件权限问题等着解决，这样就直接失去了简单跨平台的能力了。\n基于寻求更好的简单跨平台能力，又方便维护更新的原则，基于 Python，寻找可替代 cron 启动脚本的方案。\n可选的方案有几个：sched 、schedule 、APScheduler\n一个是内置 python 库，要用应该是可以用的。\n一个是说 Python job scheduling for humans，也挺不错，不过并行多任务需要额外看下文档。\n一个是说 Advanced Python Scheduler，功能最多的了，还能基于它开发成 Web 方式去管理任务。\n我由于 Tornado 用的勤快，所以我也就选择了它的 Tornado 模式，你选其它模式也是一样可以的。\nAPScheduler 的演示示例倒是写了好几种，不过反而关于如何设置定时的部分在文档里面不那么明显，就这点来说 schedule 相比就做的非常好，文档写得好这点也是可以加分很多的，如果需求真的简单又没啥特别的，我可能还是建议直接使用 schedule 好了，简单易懂。\n如何把以前的脚本直接就拿来用呢？无论这几个方案，都会让你提供一个函数，还有定时规则，如果有参数，也可以提交参数。原来的 .py 文件，基本上是会在底部 main 模块这里面写点东西，好点的可能会是一个独立函数，不好的情况，可能就会是还有很多代码。\n改是不可能再去改原有代码了的啦，最好直接拿来就用，那么这样的话，其实最好就是选 subprocess 了，使用 subprocess.run([&lsquo;python&rsquo;, &lsquo;filename.py&rsquo;]) 这样的代码去启动任何你想启动的脚本，不需要对原有代码做任何改动，这样最好不过了。\n把 subprocess.run 当作给任务的函数，需要启动的文件名命令作为参数传给它：\n&#34;&#34;&#34; Demonstrates how to use the Tornado compatible scheduler to schedule a job that executes on 3 second intervals. &#34;&#34;&#34; from datetime import datetime import os import time from tornado.ioloop import IOLoop from apscheduler.schedulers.tornado import TornadoScheduler import subprocess def tick(): print(&#39;Tick! The time is: %s&#39; % datetime.now()) if __name__ == &#39;__main__&#39;: scheduler = TornadoScheduler() scheduler.add_job(tick, &#39;interval&#39;, seconds=300) scheduler.add_job(subprocess.run, &#39;interval&#39;, minutes=5, args=([&#39;python&#39;, &#39;helloworld.py&#39;], )) scheduler.add_job(subprocess.run, &#39;cron&#39;, hour=12, minute=20, args=([&#39;python&#39;, &#39;helloworld.py&#39;], )) scheduler.start() print(&#39;Press Ctrl+{0} to exit&#39;.format(&#39;Break&#39; if os.name == &#39;nt&#39; else &#39;C&#39;)) # Execution will block here until Ctrl+C (Ctrl+Break on Windows) is pressed. try: IOLoop.instance().start() except (KeyboardInterrupt, SystemExit): pass 这样就使用一个 Scheduler 把 cron 完全替代了，这样便可以很方便去启动一个容器来运行它，不再有什么特别的命令操作和权限操作了，实现简单跨平台，而且也可以实现测试与运行两不误，更新升级的速度也会快很多。\n额外地，还想提一点：也不必说所有脚本就都必须放在这一个容器里面跑，一台机器你可以开多个容器，比如有的可能是比较早期开发的 python 2 版本的程序，而有的是 python 3 版本的程序，你可以分别创建容器去跑，这样环境隔离，就不必纠结机器上面的 python 版本的问题了，而且随时可以选择你想要的 python 版本来运行。或者甚至可以一个容器只跑一个任务，有多少个任务开多少个容器去跑，起停任务就直接起停容器就好，无需对代码进行编辑。\n当然，实际操作中根据具体情况来抉择，简单点就放一起，分开比较合适的，那就分开，反正环境隔离，起停随意，没啥问题好纠结的。\n",
        "date": 1538006400,
        "objectID": "7f4df32d44a41378f59b99af4e16ebf4",
        "relpermalink": "/python/2018-09-27-%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/",
        "section": "python",
        "title": "关于如何优雅地在容器中定时运行脚本",
        "size": 8540
    },
    {
        "content": "编程是手艺活，有自己一套趁手的工具很重要，记录下，不定期更新。\n MacBook Pro，Apple 公司出品，编程开发的最佳选择，强烈建议直接上顶配。\n PyCharm，JetBrains 公司出品的 Python IDE，社区版免费，专业版付费。\n Docker，Docker 公司出品的容器产品，Docker CE for Mac 是协助我本地开发的有力工具，同时在生产环境也基本能用 Docker 就用 Docker 进行部署运行。docker-compose 是我编排容器的方式，再搭配 Dockerfile 使用，快速自动构建并启动各种服务，几乎不用再去机器上敲什么命令了。目前我本机常规日常运行的容器（服务）数量已达 40 多个。\n Sublime，Sublime HQ Pty Ltd 出品，万能文本编辑器，免费，偶尔会弹下购买提示。\n Sourcetree，这是 Atlassian 公司出品的免费 git 图形界面客户端，这哪能不用呢。\n Paw，Paw 公司出品的 API tool for Mac，付费，主要用于 API 接口测试。\n MkDocs，MkDocs team 出品的静态页面站点生成工具，非常适合用于使用 Markdown 编写项目文档。\n Typora，typora.io 出品的 Markdown 编辑器，目前依然免费，我认为最漂亮又好用的。\n Studio 3T，3T Software Labs 出品的 MongoDB 数据库图形界面客户端，非商用版免费。\n Sequel Pro，Sequel Pro Developers 出品的 MySQL 数据库图形界面客户端，免费。\n 坚果云，上海亦存网络 出品的同步网盘服务，实现任意文件夹多端同步及版本历史，有免费方案可用，开着就好，啥也不管。\n Trello，目前已经被 Atlassian 公司收编的项目看板管理服务，免费，看板管理最佳工具。\n  ",
        "date": 1536105600,
        "objectID": "175aeb68aa325e34b272eb71d635ceb2",
        "relpermalink": "/note/2018-09-05-1522/",
        "section": "note",
        "title": "做手艺活，必然需要一套趁手的工具",
        "size": 1718
    },
    {
        "content": " 关于译文 我自己本身并不懂多少关于英文翻译的事情，这里相关的一些翻译内容也并不完全是我一个一个字手打出来的，其中绝大多数翻译内容均借助于 Google Translate 帮我实现，而我最多仅相当于一个审校的角色，对其中的句子进行一些更合理化的修改，或是用词是否恰当及准确，或是句子的通顺及逻辑合理与否。同时由于能力及精力有限，并不能绝对保证内容完全准确无误，如有发现不合理的地方或者错误的地方，还请见谅，也欢迎你反馈于我。\nTornado 是我学习 Python 后进入实际产品开发所使用到的第一个 Web 服务框架，虽然说关于它的功能有些写法可能已经用过很多次了，但是对它依然还没有一个全局的概念感受，所以想借助于这个翻译的过程，给自己加深一下关于它的设计理念、程序逻辑等等相关知识的印象。\n所以，译文只是顺便产生的结果，不过虽然即便如此，我也尽量使译文能契合中文的遣词造句，对于一些直译过来感觉奇怪的内容，会稍微做一下调整，以便容易理解。\n然后，我自己也会希望能完成所有篇章的翻译，而不是仅仅如同大家都在做的那样，只开个头，翻译一下简单入门部分，后面的更重要的细节内容就反而没有了。\n当然，其实如果能有心直接读原文，那是更好的。\n当前参考版本：Tornado 5.1\n原文链接：http://www.tornadoweb.org/\n",
        "date": 1533254400,
        "objectID": "95b3becf334b0e7490292d8cb9346886",
        "relpermalink": "/tornado/00-note/0000-about/",
        "section": "tornado",
        "title": "Tornado 0000 - 特别说明: 关于译文",
        "size": 1214
    },
    {
        "content": " 简介 Tornado 是一个用 Python 写的 Web 应用框架和异步网络库，最初是由 FriendFeed 开发的。通过使用非阻塞网络 I/O，Tornado 可以扩展到数万个开放连接（C10K），使其成为长轮询、WebSockets 和其他需要与每个用户建立长期连接的应用程序的理想选择。\nTornado 大致可分为四个主要部分：\n 一个 Web 应用框架（包括用于创建 Web 应用程序的 RequestHandler 子类，以及各种支持类）。 HTTP 的客户端和服务器端实现（AsyncHTTPClient 和 HTTPServer）。 一个异步网络库，包括 IOLoop 和 IOStream 类，它们用作 HTTP 组件的构建模块，也可用于实现其他协议。 一个协程库（tornado.gen），它允许使用比 回调 更直接了当的方式编写异步代码。这类似于 Python 3.5（async def）中引入的 原生协程 功能。建议使用 原生协程 代替 tornado.gen 模块。  Tornado Web 应用框架和 HTTP 服务器一起提供了一个针对 WSGI 的全栈替代方案。虽然也可以在 WSGI 容器（WSGIAdapter）中使用 Tornado Web 框架，或者是使用 Tornado HTTP 服务器作为其他 WSGI 框架（WSGIContainer）的容器，但是这些组合都有其局限性，如果想要充分利用 Tornado 的优势，需要同时使用 Tornado 的 Web 应用框架和 HTTP 服务器。\n​\n",
        "date": 1533254400,
        "objectID": "bb9bfdc4a51b428fa60dea18e4ed6433",
        "relpermalink": "/tornado/01-guide/0101-intro/",
        "section": "tornado",
        "title": "Tornado 0101 - 用户指南: 简介",
        "size": 1418
    },
    {
        "content": " 异步和非阻塞 I/O（Asynchronous and non-Blocking I/O） 实时 Web 功能需要为每个用户长期保持大部分空闲连接。在传统的同步 Web 服务器中，这意味着要为每个用户投入一个线程，这成本可能非常昂贵。\n为了最小化并发连接的成本，Tornado 使用单线程事件循环。这意味着所有应用程序代码都应该是异步和非阻塞的，因为一次只能有一个操作处于活动状态。\n异步 和 非阻塞 这两个术语是密切相关的，并且通常可以互换使用，但它们并不完全相同。\n阻塞（Blocking） 函数在返回之前等待某事发生时会阻塞（blocks）。一个函数可能由于多种原因而阻塞：网络 I/O、磁盘 I/O、互斥锁等。事实上，每一个函数在运行和使用 CPU 时都会至少有一点阻塞（对于一个极端的例子来说明为什么 CPU 阻塞必须像其他类型的阻塞一样严肃，考虑密码散列函数，如 bcrypt ，它设计使用数百毫秒的 CPU 时间，远远超过典型的网络或磁盘访问）。\n一个函数可能在某些方面是阻塞的，而在其他方面是非阻塞的。虽然各种阻塞都要尽量减少，但在 Tornado 的上下文中，我们通常情况是谈论在网络 I/O 上下文中的阻塞。\n异步（Asynchronous） 异步函数在它执行完成之前就会返回，并且通常在触发应用程序中的一些未来操作之前，会将某些工作放到后台去执行（相反地，同步函数一定要等到执行完它所有操作才会返回）。异步接口有很多种风格：\n 回调参数 返回占位符（Future，Promise，Deferred） 交付队列 回调注册表（例如 POSIX 信号）  无论使用哪种类型的接口，定义的每种异步函数都需要让调用者使用不同的交互方式；没有一种毫无成本的方法可以使同步函数直接变成异步函数，却又对其调用者透明的（像 gevent 这样的系统使用轻量级线程来提供与异步系统相当的性能，但它们实际上并不会使事情变成异步）。\nTornado 中的异步操作通常返回占位符对象（Futures），但一些低级别组件（例如使用回调的IOLoop）除外。Futures 通常会通过 await 或 yield 关键字转换为结果。\nExamples 这是一个同步函数示例：\nfrom tornado.httpclient import HTTPClient def synchronous_fetch(url): http_client = HTTPClient() response = http_client.fetch(url) return response.body 这是使用原生协程进行重写的异步函数：\nfrom tornado.httpclient import AsyncHTTPClient async def asynchronous_fetch(url): http_client = AsyncHTTPClient() response = await http_client.fetch(url) return response.body 或者为了与旧版本的 Python 兼容，使用 tornado.gen 模块：\nfrom tornado.httpclient import AsyncHTTPClient from tornado import gen @gen.coroutine def async_fetch_gen(url): http_client = AsyncHTTPClient() response = yield http_client.fetch(url) raise gen.Return(response.body) 协程有点神奇，但它的内部其实是这样做的：\nfrom tornado.concurrent import Future def async_fetch_manual(url): http_client = AsyncHTTPClient() my_future = Future() fetch_future = http_client.fetch(url) def on_fetch(f): my_future.set_result(f.result().body) fetch_future.add_done_callback(on_fetch) return my_future 请注意，协程在请求完成之前就返回其 Future。这就是使协程异步的原因。\n你用协程所能做的任何事情你也可以通过传递回调对象来实现，但协程提供了很重要的简化，它让你可以使用与同步模式相同的方式组织代码。这对于错误处理尤为重要，因为 try / except 块的工作方式与协程中的预期相同，而回调则会很难实现。我们将在本指南的下一部分中对协程进行深入探讨。\n​\n",
        "date": 1533254400,
        "objectID": "3df57f675a5aed8c5e15d6becdab668c",
        "relpermalink": "/tornado/01-guide/0102-async/",
        "section": "tornado",
        "title": "Tornado 0102 - 用户指南: 异步和非阻塞 I/O",
        "size": 4092
    },
    {
        "content": " 协程（Coroutines） 协程是在 Tornado 中编写异步代码的推荐方法。协程使用 Python await 或 yield 关键字来挂起和恢复执行而不是一系列回调（在 gevent 这样的框架中看到的协作轻量级线程有时也被称为协程，但在 Tornado 中所有协程都使用显式上下文切换并被称为异步函数）。\n协程几乎和同步代码一样简单，但不需要花费任何线程成本。它们还通过减少上下文切换可能发生的位置数量，使 并发性 更易于推理。\nExample:\nasync def fetch_coroutine(url): http_client = AsyncHTTPClient() response = await http_client.fetch(url) return response.body 原生协程与装饰器协程（Native vs decorated coroutines） Python 3.5 引入了async 和 await 关键字（使用这些关键字的函数也称为“原生协程（native coroutines）”）。为了与旧版本的 Python 兼容，您可以使用 tornado.gen.coroutine 装饰器来使用“装饰”或“基于 yield ”的协同程序。\n尽可能使用原生协程。仅在需要与旧版本的 Python 兼容时才使用修饰器协程。Tornado 文档中的示例通常使用原生形式。\n两种形式之间的翻译通常很简单：\n# Decorated: # Native: # Normal function declaration # with decorator # &#34;async def&#34; keywords @gen.coroutine def a(): async def a(): # &#34;yield&#34; all async funcs # &#34;await&#34; all async funcs b = yield c() b = await c() # &#34;return&#34; and &#34;yield&#34; # cannot be mixed in # Python 2, so raise a # special exception. # Return normally raise gen.Return(b) return b 两种形式的协程之间的其他差异是：\n 原生协程通常更快。 原生协程可以使用 async for 和 async with 语句，这使得某些模式更加简单。 除非 await 或 yield 它们，否则原生协程根本不会运行。装饰器协程一旦被调用就可以“在后台”开始运行。请注意，对于这两种协程，使用 await 或 yield 很重要，这样任何异常都可以使用。 装饰器协程与 concurrent.futures 包有额外的集成，允许直接生成 executor.submit 的结果。对于原生协程，请改用 IOLoop.run_in_executor。 装饰器协程通过产生列表或字典来支持等待多个对象的一些简写。在原生协程中则使用tornado.gen.multi 执行此操作。 装饰器协程可以支持与其他软件包的集成，包括通过转换函数注册表的 Twisted。要在原生协程中访问此功能，请使用 tornado.gen.convert_yielded。 装饰器协程总是返回一个 Future 对象。原生协程返回一个 awaitable 对象，而不是 Future。在 Tornado 中，两者大多可以互换。  怎么运行的 本节介绍装饰器协程的操作。原生协程在概念上是相似的，但由于与 Python 运行时的额外集成而稍微复杂一些。\n包含 yield 的函数是生成器。所有生成器都是异步的，在调用时，它们返回一个生成器对象而不是运行完成。 @gen.coroutine 装饰器通过 yield 表达式与生成器通信，并通过返回 Future 与协程的调用者通信。\n这是 coroutine 装饰器内循环的简化版本：\n# Simplified inner loop of tornado.gen.Runner def run(self): # send(x) makes the current yield return x. # It returns when the next yield is reached future = self.gen.send(self.next) def callback(f): self.next = f.result() self.run() future.add_done_callback(callback) 装饰器从生成器接收 Future，等待（不阻塞）该 Future 完成，然后 “unwraps” Future 并将结果作为 yield 表达式的结果发送回生成器。大多数异步代码从不直接接触 Future 类，除非立即将异步函数返回的 Future 传递给 yield 表达式。\n如何调用协程 协程不会以正常方式引发异常：它们引发的任何异常都将被困在等待（awaitable）对象中，直到它被 yielded 为止。这意味着以正确的方式调用协同程序很重要，否则您可能会发现未被注意到的错误：\nasync def divide(x, y): return x / y def bad_call(): # This should raise a ZeroDivisionError, but it won&#39;t because # the coroutine is called incorrectly. divide(1, 0) 在几乎所有情况下，任何调用协程的函数都必须是协程本身，并在调用中使用 await 或 yield 关键字。当覆盖超类中定义的方法时，请查阅文档以查看是否允许协程（文档应该说方法（method）“可能是协程”或“可能返回 Future”）：\nasync def good_call(): # await will unwrap the object returned by divide() and raise # the exception. await divide(1, 0) 有时你可能想要“解雇并忘记”一个协程而不等待它的结果。在这种情况下，建议使用IOLoop.spawn_callback，这使得 IOLoop 负责调用。如果失败，IOLoop 将记录堆栈跟踪：\n# The IOLoop will catch the exception and print a stack trace in # the logs. Note that this doesn&#39;t look like a normal call, since # we pass the function object to be called by the IOLoop. IOLoop.current().spawn_callback(divide, 1, 0) 对于使用 @gen.coroutine 的函数，IOLoop.spawn_callback 这种方式是建议使用，但是对于使用 async def 的函数则是必须使用（否则协程运行程序将无法启动）。\n最后，在程序的顶层，如果 IOLoop 尚未运行，你可以启动 IOLoop，运行协程，然后使用IOLoop.run_sync 方法停止 IOLoop。这通常用于启动面向批处理的程序的 main 函数：\n# run_sync() doesn&#39;t take arguments, so we must wrap the # call in a lambda. IOLoop.current().run_sync(lambda: divide(1, 0)) 协程模式 调用阻塞函数 从协程中调用阻塞函数的最简单方法是使用IOLoop.run_in_executor，它返回与协程兼容的 Futures：\nasync def call_blocking(): await IOLoop.current().run_in_executor(blocking_func, args) 并行 multi 函数接受其值为 Futures 的 lists 和 dicts，并且并行等待所有这些 Futures：\nfrom tornado.gen import multi async def parallel_fetch(url1, url2): resp1, resp2 = await multi([http_client.fetch(url1), http_client.fetch(url2)]) async def parallel_fetch_many(urls): responses = await multi ([http_client.fetch(url) for url in urls]) # responses is a list of HTTPResponses in the same order async def parallel_fetch_dict(urls): responses = await multi({url: http_client.fetch(url) for url in urls}) # responses is a dict {url: HTTPResponse} 在装饰器协程中，可以直接 yield list 或 dict：\n@gen.coroutine def parallel_fetch_decorated(url1, url2): resp1, resp2 = yield [http_client.fetch(url1), http_client.fetch(url2)]) 交错 有时去保存 Future 而不是立即 yield 它，是会很有用的，因此你可以在等待之前启动另一个操作。\nfrom tornado.gen import convert_yielded async def get(self): # convert_yielded() starts the native coroutine in the background. # This is equivalent to asyncio.ensure_future() (both work in Tornado). fetch_future = convert_yielded(self.fetch_next_chunk()) while True: chunk = yield fetch_future if chunk is None: break self.write(chunk) fetch_future = convert_yielded(self.fetch_next_chunk()) yield self.flush() 这对于装饰器协程来说更容易一些，因为它们在被调用时就立即启动：\n@gen.coroutine def get(self): fetch_future = self.fetch_next_chunk() while True: chunk = yield fetch_future if chunk is None: break self.write(chunk) fetch_future = self.fetch_next_chunk() yield self.flush() 循环 在原生协程中，可以使用 async for。在旧版本的 Python 中，使用协程进行循环是很棘手的，因为无法在 for 循环或 while 循环的每次迭代中产生并捕获 yield 的结果。相反，您需要将循环条件与访问结",
        "date": 1533254400,
        "objectID": "cab2296fa94d9c3c7a8073466ac434c2",
        "relpermalink": "/tornado/01-guide/0103-coroutines/",
        "section": "tornado",
        "title": "Tornado 0103 - 用户指南: 协程",
        "size": 10008
    },
    {
        "content": " 队列（Queue） 示例 - 并发 Web 蜘蛛 Tornado 的 tornado.queues 模块为协程实现异步生产者/消费者模式，类似于 Python 标准库的 queue 模块为线程实现的模式。\n产生 Queue.get 的协程暂停，直到队列中有项目为止。如果队列设置了最大大小，则会产生 Queue.put 的协程暂停，直到有另一个项目的空间。\nQueue 维护未完成任务的计数，从零开始。put 增加计数；task_done 递减它。\n在此处的 web-spider 示例中，队列开始仅包含 base_url。当一个 worker 获取一个页面时，它会解析链接并将新的链接放入队列中，然后调用 task_done 来减少一次计数器。最终，一个工作者获取一个页面，其 URL 之前已经被看到，并且队列中也没有剩余的工作。因此，该worker 对task_done 的调用将计数器减少为零。正在等待 join 的主协程已取消暂停并完成。\n#!/usr/bin/env python3 import time from datetime import timedelta from html.parser import HTMLParser from urllib.parse import urljoin, urldefrag from tornado import gen, httpclient, ioloop, queues base_url = &#39;http://www.tornadoweb.org/en/stable/&#39; concurrency = 10 async def get_links_from_url(url): &#34;&#34;&#34;Download the page at `url` and parse it for links. Returned links have had the fragment after `#` removed, and have been made absolute so, e.g. the URL &#39;gen.html#tornado.gen.coroutine&#39; becomes &#39;http://www.tornadoweb.org/en/stable/gen.html&#39;. &#34;&#34;&#34; response = await httpclient.AsyncHTTPClient().fetch(url) print(&#39;fetched %s&#39; % url) html = response.body.decode(errors=&#39;ignore&#39;) return [urljoin(url, remove_fragment(new_url)) for new_url in get_links(html)] def remove_fragment(url): pure_url, frag = urldefrag(url) return pure_url def get_links(html): class URLSeeker(HTMLParser): def __init__(self): HTMLParser.__init__(self) self.urls = [] def handle_starttag(self, tag, attrs): href = dict(attrs).get(&#39;href&#39;) if href and tag == &#39;a&#39;: self.urls.append(href) url_seeker = URLSeeker() url_seeker.feed(html) return url_seeker.urls async def main(): q = queues.Queue() start = time.time() fetching, fetched = set(), set() async def fetch_url(current_url): if current_url in fetching: return print(&#39;fetching %s&#39; % current_url) fetching.add(current_url) urls = await get_links_from_url(current_url) fetched.add(current_url) for new_url in urls: # Only follow links beneath the base URL if new_url.startswith(base_url): await q.put(new_url) async def worker(): async for url in q: if url is None: return try: await fetch_url(url) except Exception as e: print(&#39;Exception: %s%s&#39; % (e, url)) finally: q.task_done() await q.put(base_url) # Start workers, then wait for the work queue to be empty. workers = gen.multi([worker() for _ in range(concurrency)]) await q.join(timeout=timedelta(seconds=300)) assert fetching == fetched print(&#39;Done in %dseconds, fetched %sURLs.&#39; % ( time.time() - start, len(fetched))) # Signal all the workers to exit. for _ in range(concurrency): await q.put(None) await workers if __name__ == &#39;__main__&#39;: io_loop = ioloop.IOLoop.current() io_loop.run_sync(main)",
        "date": 1533254400,
        "objectID": "252fc596e766f06164bb13b93581534e",
        "relpermalink": "/tornado/01-guide/0104-queues/",
        "section": "tornado",
        "title": "Tornado 0104 - 用户指南: 队列",
        "size": 5502
    },
    {
        "content": " Tornado Web 应用程序的结构 Tornado Web 应用程序通常由一个或多个 RequestHandler 子类、一个将传入请求路由到处理程序的 Application 对象和一个用于启动服务器的 main() 函数组成。\n最小的“hello world”示例如下所示：\nimport tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(&#34;Hello, world&#34;) def make_app(): return tornado.web.Application([ (r&#34;/&#34;, MainHandler), ]) if __name__ == &#34;__main__&#34;: app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() 关于 Application 对象 Application 对象负责全局配置，包括将请求映射到处理程序的路由表。\n路由表是 URLSpec 对象（或元组）的列表，每个对象包含（至少）一个正则表达式和一个处理程序类（Handler）。 顺序很重要；第一个被匹配到的规则会被优先使用。 如果正则表达式包含捕获组，则这些组是“路径参数”，并将传递给处理程序的 HTTP 方法。 如果字典作为 URLSpec 的第三个元素传递，它将提供将传递给 RequestHandler.initialize 的初始化参数。 最后，URLSpec 可能有一个名称，这将允许它与 RequestHandler.reverse_url 一起使用。\n例如，在此片段中，根 URL / 映射到 MainHandler，/story/ 后跟数字的 URL 映射到 StoryHandler。 该数字（作为字符串）传递给 StoryHandler.get。\nclass MainHandler(RequestHandler): def get(self): self.write(&#39;&lt;a href=&#34;%s&#34;&gt;link to story 1&lt;/a&gt;&#39; % self.reverse_url(&#34;story&#34;, &#34;1&#34;)) class StoryHandler(RequestHandler): def initialize(self, db): self.db = db def get(self, story_id): self.write(&#34;this is story %s&#34; % story_id) app = Application([ url(r&#34;/&#34;, MainHandler), url(r&#34;/story/([0-9]+)&#34;, StoryHandler, dict(db=db), name=&#34;story&#34;) ]) Application 构造函数采用许多关键字参数，可用于自定义应用程序的行为并启用可选功能；请参阅 Application.settings 以获取完整列表。\n继承 RequestHandler（Subclassing RequestHandler） Tornado Web 应用程序的大部分工作都是在 RequestHandler 的子类中完成的。处理程序子类的主要入口点是在处理 HTTP 方法之后命名的方法：get()，post() 等。每个处理程序可以定义一个或多个这些方法来处理不同的 HTTP 操作。如上所述，将使用与匹配的路由规则的捕获组相对应的参数来调用这些方法。\n在处理程序中，调用 RequestHandler.render 或 RequestHandler.write 等方法来生成响应。 render() 按名称加载模板，并使用给定的参数呈现它。write() 用于非基于模板的输出；它接受字符串，字节和字典（dicts 将被编码为 JSON）。\nRequestHandler 中的许多方法都设计为在子类中重写，并在整个应用程序中使用。通常定义一个 BaseHandler 类来覆盖诸如 write_error 和 get_current_user 之类的方法，然后为您的所有特定处理程序继承你自己的 BaseHandler 而不是 RequestHandler。\n处理请求输入（Handling request input） 请求处理程序（Handler）可以使用 self.request 访问表示当前请求的对象。有关于它完整的属性列表，请参阅 HTTPServerRequest 类的定义。\n它同时将为你解析 HTML 表单使用的格式的请求数据，并在 get_query_argument 和 get_body_argument 等方法中提供。\nclass MyFormHandler(tornado.web.RequestHandler): def get(self): self.write(&#39;&lt;html&gt;&lt;body&gt;&lt;form action=&#34;/myform&#34; method=&#34;POST&#34;&gt;&#39; &#39;&lt;input type=&#34;text&#34; name=&#34;message&#34;&gt;&#39; &#39;&lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt;&#39; &#39;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#39;) def post(self): self.set_header(&#34;Content-Type&#34;, &#34;text/plain&#34;) self.write(&#34;You wrote &#34; + self.get_body_argument(&#34;message&#34;)) 由于 HTML 表单编码关于参数是单个值还是一个列表是不明确的，因此RequestHandler 具有不同的方法以允许应用程序指示它是否需要列表。对于列表，请使用 get_query_arguments 和 get_body_arguments，而不是它们的单数对应项。\n通过表单上传的文件在 self.request.files 中可用，它将名称（HTML 元素的名称）映射到文件列表。每个文件都是 {&ldquo;filename&rdquo;: &hellip;, &rdquo;content_type&rdquo;: &hellip;, &rdquo;body&rdquo;: &hellip;} 形式的字典。只有在使用表单包装器上传文件时才会出现 files 对象（例如 Content-Type 是 multipart/form-data）；如果未使用此格式，则可以在 self.request.body 中使用原始上载数据。默认情况下，上传的文件在内存中完全缓冲；如果你需要处理太大而不能轻松保存在内存中的文件，请参阅 stream_request_body 类装饰器。\n在 demos 目录中，file_receiver.py 显示了接收文件上载的两种方法。\n由于 HTML 表单编码的怪癖（例如，围绕单数与多数参数的歧义），Tornado 不会尝试将表单参数与其他类型的输入统一起来。特别是，我们不解析 JSON 请求体。希望使用 JSON 而不是表单编码的应用程序可能会覆盖准备解析其请求：\ndef prepare(self): if self.request.headers.get(&#34;Content-Type&#34;, &#34;&#34;).startswith(&#34;application/json&#34;): self.json_args = json.loads(self.request.body) else: self.json_args = None 重写 RequestHandler 中的方法（Overriding RequestHandler methods） 除了 get() / post() 等这些方法，RequestHandler 中的某些其他方法被设计为在必要时被子类覆盖。在每个请求中，都会发生以下调用序列：\n 每个请求都会创建一个新的 RequestHandler 对象\n 使用 Application 配置中的初始化参数调用 initialize() 。 initialize 通常应该只保存传递给成员变量的参数；它可能不会产生任何输出或调用 send_error 等方法。\n prepare() 被调用。这在所有处理程序子类共享的基类中最有用，因为无论使用哪种 HTTP方法都会调用 prepare。准备可能产生输出；如果它调用 finish（或 redirect 等），则处理在此处停止。\n 其中一个 HTTP 方法称为：get()，post()，put() 等。如果 URL 正则表达式包含捕获组，则它们将作为参数传递给此方法。\n 请求完成后，调用 on_finish()。对于大多数处理程序，这是在 get() 返回后立即执行的；对于使用 tornado.web.asynchronous 装饰器的处理程序，它是在调用 finish() 之后。\n  设计为被覆盖的所有方法都在 RequestHandler 文档中注明。一些最常被覆盖的方法包括：\n write_error - 输出 HTML 以在错误页面上使用。 on_connection_close - 在客户端断开连接时调用；应用程序可以选择检测此情况并停止进一步处理。请注意，无法保证可以立即检测到已关闭的连接。 get_current_user - 请参阅用户身份验证 get_user_locale - 返回用于当前用户的 Locale 对象 set_default_headers - 可用于在响应上设置其他标头（例如自定义服务器标头）  错误处理（Error Handling） 如果处理程序引发异常，Tornado 将调用 RequestHandler.write_error 来生成错误页面。 tornado.web.HTTPError 可用于生成指定的状态代码；所有其他例外都返回 500 状态。\n默认错误页面包括调试模式下的堆栈跟踪和错误的单行描述（例如：“500：内部服务器错误”）。要生成自定义错误页面，请覆盖 RequestHandler.write_error（可能在所有处理程序共享的基类中）。此方法通常可以通过诸如 write 和 render 之类的方法生成输出。如果错误是由异常引起的，则 exc_info 三元组将作为关键字参数传递（请注意，此异常不保证是sys.exc_info 中的当前异常，因此 write_error 必须使用例如 traceback.format_exception 而不是 traceback.format_exc ）。\n也可以通过调用 set_status，编写响应和返回，从常规处理程序方法而不是 write_error 生成错误页面。在简单返回不方便的情况下，它可以引发特殊的异常 tornado.web.Finish，使得不用调用 write_error 就可以终止处理程序。\n对于 404 错误，请使用 default_handler_class 应用程序设置。此处理程序应该覆盖 prepare而不是像 get() 这样的更具体的方法",
        "date": 1533254400,
        "objectID": "aa77ff89b3253f73cbb4ab94776a1694",
        "relpermalink": "/tornado/01-guide/0105-structure/",
        "section": "tornado",
        "title": "Tornado 0105 - 用户指南: Tornado Web 应用程序的结构",
        "size": 10018
    },
    {
        "content": " 模板和UI Tornado 包含一种简单，快速，灵活的模板语言。本节介绍该语言以及国际化等相关问题。\nTornado 也可以与任何其他 Python 模板语言一起使用，尽管没有明确地规定如何将这些系统集成到 RequestHandler.render 中，你只需将模板渲染为字符串并将其传递给RequestHandler.write 就可以了。\n配置模板 默认情况下，Tornado 会在与引用它们的 .py 文件相同的目录中查找模板文件。 要将模板文件放在不同的目录中，请使用 template_path 应用程序设置 （如果不同的处理程序具有不同的模板路径，则覆盖 RequestHandler.get_template_path）。\n要从非文件系统位置加载模板，请将 tornado.template.BaseLoader 子类化，并将实例作为 template_loader 应用程序设置传递。\n默认情况下，编译的模板会被缓存；要关闭此缓存和重新加载模板，以便始终可以看到对底层文件的更改，请使用应用程序设置 compiled_template_cache = False 或 debug = True。\n模板语法 Tornado 模板只是 HTML（或任何其他基于文本的格式），其中 Python 控件序列和表达式嵌入在标记中：\n&lt;html&gt; &lt;head&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; {% for item in items %} &lt;li&gt;{{ escape(item) }}&lt;/li&gt; {% end %} &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 如果您将此模板另存为 “template.html” 并将其放在与 Python 文件相同的目录中，则可以使用以下内容呈现此模板：\nclass MainHandler(tornado.web.RequestHandler): def get(self): items = [&#34;Item 1&#34;, &#34;Item 2&#34;, &#34;Item 3&#34;] self.render(&#34;template.html&#34;, title=&#34;My title&#34;, items=items) Tornado 模板支持控制语句和表达式。控制语句由 {％ 和 ％} 包围，例如 {％ if len (items) &gt; 2 ％} 。 表达式由 {{ 和 }} 包围，例如 {{ items [0] }} 。\n控制语句或多或少地映射到 Python 语句。 我们支持 if, for, while 和 try，所有这些都以 {％ end ％} 终止。 我们还使用 extends 和 block 语句支持模板继承，这些语句在 tornado.template 的文档中有详细描述。\n表达式可以是任何 Python 表达式，包括函数调用。模板代码在包含以下对象和函数的命名空间中执行（请注意，此列表适用于使用 RequestHandler.render 和 render_string 呈现的模板。如果您直接在 RequestHandler 之外使用 tornado.template 模块，则许多条目都是不存在的）。\n escape: alias for tornado.escape.xhtml_escape xhtml_escape: alias for tornado.escape.xhtml_escape url_escape: alias for tornado.escape.url_escape json_encode: alias for tornado.escape.json_encode squeeze: alias for tornado.escape.squeeze linkify: alias for tornado.escape.linkify datetime: the Python datetime module handler: the current RequestHandler object request: alias for handler.request current_user: alias for handler.current_user locale: alias for handler.locale _: alias for handler.locale.translate static_url: alias for handler.static_url xsrf_form_html: alias for handler.xsrf_form_html reverse_url: alias for Application.reverse_url All entries from the ui_methods and ui_modules Application settings Any keyword arguments passed to render or render_string  在构建实际应用程序时，如果您将要使用 Tornado 模板的所有功能，尤其是模板继承。请阅读 tornado.template 部分中有关这些功能的所有内容（某些功能，包括 UIModules 在 tornado.web 模块中实现）\n在幕后，Tornado 模板直接转换为 Python。您在模板中包含的表达式将逐字复制到表示模板的 Python 函数中。我们不会试图阻止模板语言中的任何内容，相对于其他更严格的模板系统，我们明确地提供它们所没有的灵活性。因此，如果在模板表达式中编写随机内容，则在执行模板时会出现随机 Python 错误。\n默认情况下，使用 tornado.escape.xhtml_escape 函数对所有模板输出进行转义。要更改此行为，可通过将 autoescape = None 传递给 Application 或 tornado.template.Loader 构造函数，将全局更改此行为；对于一个模板文件可使用 {％ autoescape None ％} 指令；对于单个表达式则可以通过替换 {{ &hellip; }} 为 {％ raw &hellip; ％} 的方式来实现。另外，在上述这些地方，也可以使用替代转义函数的名称而不是 None。\n请注意，虽然 Tornado 的自动转义有助于避免 XSS 漏洞，但在所有情况下都是不够的。出现在某些位置的表达式（例如 Javascript 或 CSS）可能需要额外的转义。此外，必须注意始终在可能包含不受信任内容的 HTML 属性中使用双引号和 xhtml_escape，或者必须为属性使用单独的转义函数（请参阅 http://wonko.com/post/html-escaping ）\n国际化 当前用户的区域设置（无论它们是否已登录）始终在请求处理程序中作为 self.locale 提供，在模板中始终作为 locale 提供。语言环境的名称（例如 en_US）可用作 locale.name，您可以使用 Locale.translate 方法转换字符串。模板还具有可用于字符串转换的全局函数调用 _() 。 translate 函数有两种形式：\n_(&#34;Translate this string&#34;) 它根据当前语言环境直接转换字符串。\n以及：\n_(&#34;A person liked this&#34;, &#34;%(num)dpeople liked this&#34;, len(people)) % {&#34;num&#34;: len(people)} 它根据第三个参数的值转换一个可以是单数或复数的字符串。在上面的示例中，如果len(people)为 1，则将返回第一个字符串的转换，否则将返回第二个字符串的转换。\n最常见的翻译模式是使用 Python 命名的占位符作为变量（上例中的 ％(num)d ），因为占位符可以在翻译中移动。\n这是一个适当的国际化模板：\n&lt;html&gt; &lt;head&gt; &lt;title&gt;FriendFeed - {{ _(&#34;Sign in&#34;) }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&#34;{{ request.path }}&#34; method=&#34;post&#34;&gt; &lt;div&gt;{{ _(&#34;Username&#34;) }} &lt;input type=&#34;text&#34; name=&#34;username&#34;/&gt;&lt;/div&gt; &lt;div&gt;{{ _(&#34;Password&#34;) }} &lt;input type=&#34;password&#34; name=&#34;password&#34;/&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&#34;submit&#34; value=&#34;{{ _(&#34;Sign in&#34;) }}&#34;/&gt;&lt;/div&gt; {% module xsrf_form_html() %} &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 默认情况下，我们使用用户浏览器发送的 Accept-Language 标头检测用户的语言环境。如果找不到合适的 Accept-Language 值，我们选择 en_US。如果您允许用户将其区域设置作为首选项，则可以通过覆盖 RequestHandler.get_user_locale 来覆盖此默认区域设置选择：\nclass BaseHandler(tornado.web.RequestHandler): def get_current_user(self): user_id = self.get_secure_cookie(&#34;user&#34;) if not user_id: return None return self.backend.get_user_by_id(user_id) def get_user_locale(self): if &#34;locale&#34; not in self.current_user.prefs: # Use the Accept-Language header return None return self.current_user.prefs[&#34;locale&#34;] 如果 get_user_locale 返回 None，我们将返回 Accept-Language 标头。\ntornado.locale 模块支持以两种格式加载翻译：gettext 和相关工具使用的 .mo 格式，以及简单的 .csv 格式。 应用程序通常会在启动时调用 tornado.locale.load_translations 或 tornado.locale.load_gettext_translations ；有关支持的格式的更多详细信息，请参阅这些方法。\n您可以使用 tornado.locale.get_supported_locales() 获取应用程序中受支持的语言环境列表。根据支持的语言环境，选择用户的语言环境作为最接近的匹配项。例如，如果用户的语言环境是 es_GT，并且支持 es 语言环境，那么 self.local",
        "date": 1533254400,
        "objectID": "6c94bf0dc08c792256b621b1a354a1f9",
        "relpermalink": "/tornado/01-guide/0106-templates/",
        "section": "tornado",
        "title": "Tornado 0106 - 用户指南: 模板与 UI",
        "size": 10022
    },
    {
        "content": " 认证与安全 Cookies 和 secure cookies 您可以使用 set_cookie 方法在用户的浏览器中设置 cookies：\nclass MainHandler(tornado.web.RequestHandler): def get(self): if not self.get_cookie(&#34;mycookie&#34;): self.set_cookie(&#34;mycookie&#34;, &#34;myvalue&#34;) self.write(&#34;Your cookie was not set yet!&#34;) else: self.write(&#34;Your cookie was set!&#34;) Cookies 不安全，客户可以轻松修改。如果您需要设置 Cookies，例如，识别当前登录的用户，则需要对 Cookies 进行签名以防止伪造。Tornado 使用 set_secure_cookie 和 get_secure_cookie 方法来支持签名的 Cookies。要使用这些方法，您需要在创建应用程序时指定名为 cookie_secret 的密钥。您可以将应用程序设置作为关键字参数传递给应用程序：\napplication = tornado.web.Application([ (r&#34;/&#34;, MainHandler), ], cookie_secret=&#34;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&#34;) 除了时间戳和 HMAC 签名之外，签名 cookies 还包含 cookies 的编码值。如果 cookies 是旧的或签名不匹配，get_secure_cookie 将返回 None，就像没有设置 cookies 一样。以上示例的安全版本：\nclass MainHandler(tornado.web.RequestHandler): def get(self): if not self.get_secure_cookie(&#34;mycookie&#34;): self.set_secure_cookie(&#34;mycookie&#34;, &#34;myvalue&#34;) self.write(&#34;Your cookie was not set yet!&#34;) else: self.write(&#34;Your cookie was set!&#34;) Tornado 的 secure cookies 确保完整性但不保密。也就是说，cookies 不能被修改，但其内容可以被用户看到。cookie_secret 是一个对称密钥，必须保密 - 任何获得此密钥值的人都可以生成自己的签名 cookies。\n默认情况下，Tornado 的 secure cookies 将在 30 天后过期。要更改此设置，请使用 set_secure_cookie 的 expires_days 关键字参数和 get_secure_cookie 的 max_age_days 参数。这两个值是分开传递的，因此您可以：例如对于大多数用途，有一个有效期为 30 天的 cookies，但对于某些敏感操作（例如更改帐单信息），在读取 cookies 时使用较小的 max_age_days。\nTornado 还支持多个签名密钥以启用签名密钥轮换。 然后 cookie_secret 必须是一个 dict，整数键版本作为键，相应的密钥作为值。然后必须将当前使用的签名密钥设置为 key_version 应用程序设置，但如果在 cookie 中设置了正确的密钥版本，则允许 dict 中的所有其他密钥进行 cookie 签名验证。要实现 cookie 更新，可以通过 get_secure_cookie_key_version 查询当前的签名密钥版本。\n用户认证 当前经过身份验证的用户在每个请求处理程序中都可用作 self.current_user，在每个模板中都可用作 current_user。默认情况下，current_user 为 None。\n要在应用程序中实现用户身份验证，您需要覆盖请求处理程序中的 get_current_user() 方法，以根据（例如）cookie 的值确定当前用户。这是一个允许用户只需指定昵称就可以登录应用程序的示例，然后将其保存在 cookie 中：\nclass BaseHandler(tornado.web.RequestHandler): def get_current_user(self): return self.get_secure_cookie(&#34;user&#34;) class MainHandler(BaseHandler): def get(self): if not self.current_user: self.redirect(&#34;/login&#34;) return name = tornado.escape.xhtml_escape(self.current_user) self.write(&#34;Hello, &#34; + name) class LoginHandler(BaseHandler): def get(self): self.write(&#39;&lt;html&gt;&lt;body&gt;&lt;form action=&#34;/login&#34; method=&#34;post&#34;&gt;&#39; &#39;Name: &lt;input type=&#34;text&#34; name=&#34;name&#34;&gt;&#39; &#39;&lt;input type=&#34;submit&#34; value=&#34;Sign in&#34;&gt;&#39; &#39;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#39;) def post(self): self.set_secure_cookie(&#34;user&#34;, self.get_argument(&#34;name&#34;)) self.redirect(&#34;/&#34;) application = tornado.web.Application([ (r&#34;/&#34;, MainHandler), (r&#34;/login&#34;, LoginHandler), ], cookie_secret=&#34;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&#34;) 您可以要求用户使用 Python decorator tornado.web.authenticated 登录。如果请求转到使用此装饰器的方法，并且用户未登录，则会将它们重定向到 login_url（另一个应用程序设置）。上面的例子可以重写：\nclass MainHandler(BaseHandler): @tornado.web.authenticated def get(self): name = tornado.escape.xhtml_escape(self.current_user) self.write(&#34;Hello, &#34; + name) settings = { &#34;cookie_secret&#34;: &#34;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&#34;, &#34;login_url&#34;: &#34;/login&#34;, } application = tornado.web.Application([ (r&#34;/&#34;, MainHandler), (r&#34;/login&#34;, LoginHandler), ], **settings) 如果使用 authenticated 装饰器装饰 post() 方法，并且用户未登录，则服务器将发送 403 响应。@authenticated 装饰器只是简写 if not self.current_user: self.redirect()，可能不适合非基于浏览器的登录方案。\n查看 Tornado Blog 示例应用程序，获取使用身份验证的完整示例（并将用户数据存储在 MySQL 数据库中）。\n第三方认证 tornado.auth 模块为网络上许多最受欢迎的网站实施身份验证和授权协议，包括Google / Gmail，Facebook，Twitter 和 FriendFeed。该模块包括通过这些站点记录用户的方法，以及在适用的情况下授权访问服务的方法，以便您可以例如下载用户的地址簿或代表他们发布 Twitter 消息。\n以下是使用 Google 进行身份验证的示例处理程序，将 Google 凭据保存在 Cookie 中以供日后访问：\nclass GoogleOAuth2LoginHandler(tornado.web.RequestHandler, tornado.auth.GoogleOAuth2Mixin): async def get(self): if self.get_argument(&#39;code&#39;, False): user = await self.get_authenticated_user( redirect_uri=&#39;http://your.site.com/auth/google&#39;, code=self.get_argument(&#39;code&#39;)) # Save the user with e.g. set_secure_cookie else: await self.authorize_redirect( redirect_uri=&#39;http://your.site.com/auth/google&#39;, client_id=self.settings[&#39;google_oauth&#39;][&#39;key&#39;], scope=[&#39;profile&#39;, &#39;email&#39;], response_type=&#39;code&#39;, extra_params={&#39;approval_prompt&#39;: &#39;auto&#39;}) 有关更多详细信息，请参阅 tornado.auth 模块文档。\n跨站点请求伪造保护 跨站点请求伪造（XSRF）是个性化 Web 应用程序的常见问题。有关 XSRF 如何工作的更多信息，请参阅 Wikipedia 文章。\n普遍接受的防止 XSRF 的解决方案是为每个用户提供不可预测的值，并将该值作为附加参数包含在您网站上的每个表单提交中。如果 cookie 和表单提交中的值不匹配，则该请求可能是伪造的。\nTornado 内置 XSRF 保护。要将其包含在您的站点中，请配置应用程序设置 xsrf_cookies：\nsettings = { &#34;cookie_secret&#34;: &#34;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&#34;, &#34;login_url&#34;: &#34;/login&#34;, &#34;xsrf_cookies&#34;: True, } application = tornado.web.Application([ (r&#34;/&#34;, MainHandler), (r&#34;/login&#34;, LoginHandler), ],",
        "date": 1533254400,
        "objectID": "8c69b5b8d04c7755b15c7856960d206f",
        "relpermalink": "/tornado/01-guide/0107-security/",
        "section": "tornado",
        "title": "Tornado 0107 - 用户指南: 认证与安全",
        "size": 10022
    },
    {
        "content": " 运行和部署 由于 Tornado 提供自己的 HTTPServer，因此运行和部署它与其他 Python Web 框架略有不同。您可以编写一个启动服务器的 main() 函数，而不是配置 WSGI 容器来查找应用程序：\ndef main(): app = make_app() app.listen(8888) IOLoop.current().start() if __name__ == &#39;__main__&#39;: main() 配置操作系统或进程管理器以运行此程序以启动服务器。请注意，可能需要增加每个进程的打开文件数（以避免“打开太多文件”-Error）。要提高此限制（例如将其设置为50000），您可以使用 ulimit 命令，修改 /etc/security/limits.conf 或在 supervisord 配置中设置 minfds。\n进程和端口 由于Python GIL（全局解释器锁），有必要运行多个 Python 进程以充分利用多 CPU 机器。通常，每个 CPU 最好运行一个进程。\nTornado 包含一个内置的多进程模式，可以同时启动多个进程。这需要对标准主要功能稍作改动：\ndef main(): app = make_app() server = tornado.httpserver.HTTPServer(app) server.bind(8888) server.start(0) # forks one process per cpu IOLoop.current().start() 这是启动多个进程并使它们共享同一端口的最简单方法，尽管它有一些限制。首先，每个子进程都有自己的 IOLoop，因此在 fork 之前没有任何东西触及全局 IOLoop 实例（甚至间接）是很重要的。 其次，在此模型中很难进行零停机更新。最后，由于所有进程共享同一个端口，因此单独监视它们更加困难。\n对于更复杂的部署，建议单独启动进程，并让每个进程侦听不同的端口。supervisord 的 “process groups” 功能是安排此功能的一种好方法。当每个进程使用不同的端口时，通常需要外部负载均衡器（如 HAProxy 或 nginx）向外部访问者提供单个地址。\n在负载均衡器后面运行 在像 nginx 这样的负载均衡器后面运行时，建议将 xheaders = True 传递给 HTTPServer 构造函数。这将告诉 Tornado 使用像 X-Real-IP 这样的标头来获取用户的 IP 地址，而不是将所有流量归因于平衡器的 IP 地址。\n这是一个准系统 nginx 配置文件，其结构类似于我们在 FriendFeed 上使用的配置文件。它假定 nginx 和 Tornado 服务器在同一台机器上运行，并且四个 Tornado 服务器在端口 8000 - 8003 上运行：\nuser nginx; worker_processes 1; error_log /var/log/nginx/error.log; pid /var/run/nginx.pid; events { worker_connections 1024; use epoll; } http { # Enumerate all the Tornado servers here  upstream frontends { server 127.0.0.1:8000; server 127.0.0.1:8001; server 127.0.0.1:8002; server 127.0.0.1:8003; } include /etc/nginx/mime.types; default_type application/octet-stream; access_log /var/log/nginx/access.log; keepalive_timeout 65; proxy_read_timeout 200; sendfile on; tcp_nopush on; tcp_nodelay on; gzip on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/html text/css text/xml application/x-javascript application/xml application/atom+xml text/javascript; # Only retry if there was a communication error, not a timeout  # on the Tornado server (to avoid propagating &#34;queries of death&#34;  # to all frontends)  proxy_next_upstream error; server { listen 80; # Allow file uploads  client_max_body_size 50M; location ^~ /static/ { root /var/www; if ($query_string) { expires max; } } location = /favicon.ico { rewrite (.*) /static/favicon.ico; } location = /robots.txt { rewrite (.*) /static/robots.txt; } location / { proxy_pass_header Server; proxy_set_header Host $http_host; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://frontends; } } } 静态文件和积极的文件缓存 您可以通过在应用程序中指定 static_path 设置来提供 Tornado 中的静态文件：\nsettings = { &#34;static_path&#34;: os.path.join(os.path.dirname(__file__), &#34;static&#34;), &#34;cookie_secret&#34;: &#34;__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__&#34;, &#34;login_url&#34;: &#34;/login&#34;, &#34;xsrf_cookies&#34;: True, } application = tornado.web.Application([ (r&#34;/&#34;, MainHandler), (r&#34;/login&#34;, LoginHandler), (r&#34;/(apple-touch-icon\\.png)&#34;, tornado.web.StaticFileHandler, dict(path=settings[&#39;static_path&#39;])), ], **settings) 此设置将自动使来自该静态目录的所有以 /static/serve 开头的请求（例如，http:// localhost:8888/static/foo.png）从指定的静态目录提供文件 foo.png。我们还自动从静态目录中提供 /robots.txt 和 /favicon.ico（即使它们不以 /static/ 前缀开头）。\n在上面的设置中，我们已经明确地将 Tornado 配置为使用 StaticFileHandler 从 root 用户提供 apple-touch-icon.png，尽管它实际上位于静态文件目录中。（正则表达式中的捕获组必须告诉 StaticFileHandler 所请求的文件名；回想一下，捕获组作为方法参数传递给处理程序。）您可以执行相同的操作，例如来自站点根目录的 sitemap.xml。当然，您也可以通过在 HTML 中使用相应的 标记来避免伪造 root apple-touch-icon.png\n为了提高性能，浏览器通常会积极地缓存静态资源，因此浏览器不会发送可能阻止页面呈现的不必要的 If-Modified-Since 或 Etag 请求。Tornado 支持这种开箱即用的静态内容版本控制。\n要使用此功能，请在模板中使用 static_url 方法，而不是直接在 HTML 中键入静态文件的URL：\n&lt;html&gt; &lt;head&gt; &lt;title&gt;FriendFeed - {{ _(&#34;Home&#34;) }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;img src=&#34;{{ static_url(&#34;images/logo.png&#34;) }}&#34;/&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; static_url() 函数将该相对路径转换为看起来像 /static/images/logo.png?v=aae54 的URI。 v 参数是 logo.png 中内容的哈希值，它的存在使得 Tornado 服务器向用户的浏览器发送缓存头，这将使浏览器无限期地缓存内容。\n由于 v 参数基于文件的内容，如果更新文件并重新启动服务器，它将开始发送新的 v 值，因此用户的浏览器将自动获取新文件。如果文件的内容没有改变，浏览器将继续使用本地缓存的副本，而无需检查服务器上的更新，从而显着提高了渲染性能。\n在生产中，您可能希望从更优化的静态文件服务器（如 nginx）提供静态文件。您几乎可以配置任何 Web 服务器以识别 static_url() 使用的版本标记，并相应地设置缓存标头。以下是我们在 FriendFeed 中使用的 nginx 配置的相关部分：\nlocation /static/ { root /var/friendfeed/static; if ($query_string) { expires max; } } 调试模式和自动重新加载 如果将 debug = True 传递给 Application 构造函数，则应用程序将以调试/开发模式运行。在此模式下，将启用在开发时为方便起见的几个功能（每个功能也可作为单独的标志使用；如果两者都指定，则单个标志优先）：\n autoreload = True：应用程序将监视其源文件的更改，并在发生任何更改时重新加载。 这减少了在开发期间手动重启服务器的需要。但是，某些故障（例如导入时的语法错误）仍然可能以调试模式当前无法恢复的方式关闭服务器。\n compiled_template_cache = False：不会缓存模板。\n static_hash_cache = False：静态文件哈希值（由 static_url 函数使用）不会被缓存\n serve_traceback = True：当未捕获 RequestHandler 中的异常时，将生成包含堆栈跟踪的错误页面。\n  自动重载模式与 HTTPServer 的多进程模式不兼容。如果使用自动加载模式，则不得向 HTTPServer.start 提供除 1 以外的参数（或调用 tornado.process.fork_processes）。\n调试模式的自动重新加载功能可作为 tornado.autoreload 中的独立模块使用。这两者可以结合使用以提供针对语法错误的额外稳健性：在应用程序中设置 ",
        "date": 1533254400,
        "objectID": "190366d2bbf77532348a82768ef32a00",
        "relpermalink": "/tornado/01-guide/0108-running/",
        "section": "tornado",
        "title": "Tornado 0108 - 用户指南: 运行与部署",
        "size": 10010
    },
    {
        "content": "不得不说，Pandas 是我很喜欢的一个工具，之前在外贸公司做采购和物流相关方面事情的时候，跟 Excel 结下了不浅的关系。在处理 Excel 的数据过程中，依照对数据业务的理解也使得后来去理解 MySQL 相关的数据的关系模型有了一些清晰的思维过程。\n如果说创业公司需要什么工具能支撑起业务快速发展和需求变化，Excel 是一个利器，这在很多行业的实际应用实践中都得到过检验，而我自己也自认为曾经利用它在很长一段时间里支撑起了一家公司的核心业务流程。\n但凡是工具就有长短，Excel 虽是利器，可能在高手眼里表还未开，数据已经在脑海里飞过了千百次，即使是个小白也能对着那横竖格子拥有完整的操作能力，但是，任何事物到了一定量级，就性质变了，而更甚至涉及到多人、跨部门共享操作，就更难以完成有效的数据流通了。\n所以有长有短，有些地方，还是需要有别的解决方案，比如搞个数据库，然后至于如何利用这个数据库，开发一个 ERP 也好，简单整个 web 数据界面也罢，那就看各自能力和想象力了。\n额，又啰嗦了。\n在 Python 的世界里面，使用 Pandas 来读取 Excel 数据并操作数据，是一种非常有效的工作方法。如果你有较大的数据量需要操作和计算，又或者有很多的固定步骤需要频繁处理，都可以使用 Pandas 来处理，它，简单说就是：工业级的数据处理工具。\n今天提个小点：使用 Pandas 处理各种不同的列名称，对它们进行重命名。\n在大多数时候，我们会有个数据处理流程，这个流程的开始负责接收一批数据，然后中间经过各种处理和计算，输出为我们需要的结果，这就是：输入 &ndash;&gt; 处理与计算 &ndash;&gt; 输出。\n这很像一个函数的概念对吧，可以这样理解了。\n不过在输入的时候，我们会考虑使用一种数据标准，仅当数据符合我们的需求的时候，我们才能对其进行正常的处理并得到正确的输出。而一旦数据不符合需要的标准了，就很难得到正确的结果了。\n这时候就需要在进行输入时候的前面一个再加一步：预处理。\n在预处理的时候，常见就有个列名称标准化，在 Excel 中我们可能不太方便在面对很多种表头，还能正常合并数据然后一次处理的，而如果要每种表头都单独处理，就又特别磨炼人性的价值观了。而如果是在 Pandas 里面，我们可以利用 pandas.DataFrame.rename 这个方法来对任意各种表头进行统一标准化，以实现数据标准化中的列名称标准化，也可以叫数据字段标准化。\n写出代码大概会是下面这样子：\nimport pandas as pd import numpy as np # 维护好各种表头对应关系的标准化数据 columns_rename = { &#34;packetid&#34;: &#34;ProductID&#34;, &#34;packet id&#34;: &#34;ProductID&#34;, &#34;packet-id&#34;: &#34;ProductID&#34;, &#34;packet_id&#34;: &#34;ProductID&#34;, &#34;stkid&#34;: &#34;ProductID&#34;, &#34;stk id&#34;: &#34;ProductID&#34;, &#34;stk-id&#34;: &#34;ProductID&#34;, &#34;stk_id&#34;: &#34;ProductID&#34;, &#34;stock&#34;: &#34;ProductID&#34;, &#34;stock#&#34;: &#34;ProductID&#34;, &#34;stock #&#34;: &#34;ProductID&#34;, &#34;stockno&#34;: &#34;ProductID&#34;, &#34;stock no&#34;: &#34;ProductID&#34;, &#34;stock-no&#34;: &#34;ProductID&#34;, &#34;stock_no&#34;: &#34;ProductID&#34;, &#34;place&#34;: &#34;CountryCode&#34;, &#34;地点&#34;: &#34;CountryCode&#34;, &#34;所在地&#34;: &#34;CountryCode&#34;, &#34;locationcode&#34;: &#34;CountryCode&#34;, &#34;location code&#34;: &#34;CountryCode&#34;, &#34;location-code&#34;: &#34;CountryCode&#34;, &#34;location_code&#34;: &#34;CountryCode&#34;, &#34;location&#34;: &#34;CountryCode&#34;, &#34;source&#34;: &#34;CountryCode&#34;, &#34;country&#34;: &#34;CountryCode&#34; } # 假如你有个叫 data.xlsx 的表格文件，把它读进来，读完就得到一个 DataFrame # 它跟表格很类似，我一般简称为 df，然后就开始对它进行各种操作 df = pd.read_excel(&#39;data.xlsx&#39;) # 先可以看一眼前几条数据，默认 5 条 print(df.head()) # 先把表头做下小写，以及去除多余空白字符 df.columns = df.columns.str.lower().strip() # 然后对列进行重命名，如果有匹配上的列名称，就会帮你全部重命名了 df = df.rename(columns=columns_rename) # 而后再做下一步操作 # …… 然后再贴个官方文档链接：pandas.DataFrame.rename\n文档很直观，信息量也足够，具体怎么玩就看你的了。\n",
        "date": 1530835200,
        "objectID": "708dee7fe2facfae9a150225516a9905",
        "relpermalink": "/python/2018-07-06-pandas-%E5%AF%B9-dataframe-%E7%9A%84%E5%88%97%E5%90%8D%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%91%BD%E5%90%8D/",
        "section": "python",
        "title": "Pandas: 对 DataFrame 的列名进行重命名",
        "size": 5174
    },
    {
        "content": "话说接触 Python 这货也很久了，不过一段时间后就等着跨一个坎，不然对技术的理解如何升阶。\n要说有哪本书完全啃下来了，肯定地说，一本都没有，真是情况是，大多是泛泛而看，等到下一段时间，又被新的信息所吸引，这就是信息焦虑，如果无法处理得好的话，最终就是什么东西都是只是听到过见到过甚至开始过，但是，却并没有深入过。\n时间过去了，而你，最终什么都不擅长。\n倒不是说绝对的不好，见识广阔思路开放，是有必要的，但也总要选一个入口走深一点，知道了全国几百个溶洞的所在地，可一个都没真正走进去过的话，这就不能叫溶洞探险家。\n我时常会望着架子上的书脊发呆，望着那些名字的背后有着多么深奥的学问，也带有一种难以诉说的恐惧感，就如同乘一叶小舟漂浮在大海之上，可技术海洋太大又太深，每日还波涛汹涌不断快速进化，恐怕是处于这个时代的 IT 技术人实实在在的切身感受。\n但又说时代更好也罢，知识付费拔地而起，原来难以寻找的知识现在人家双手捧上，而唯独永远欠缺的，是 shi jian，是时间，也是实践。\n不求太多，只求一点一滴吧，何况生活情绪万变，儿女情长，家长里短各种事务，人们永远怀念学生时代，这都是有切实支撑的。\n增加的 note 板块暂时先只在 Jeremy&rsquo;s blog 进行更新，往后是否发公众号再看情况，一些碎碎片片的东西，算是找个地方让它们留下点记忆。\n",
        "date": 1530748800,
        "objectID": "c86882d490b411b198baa30f7c108da2",
        "relpermalink": "/post/2018-07-05-%E7%BB%99%E7%BD%91%E7%AB%99%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%88%AB%E5%8F%AB-note/",
        "section": "post",
        "title": "给网站增加一个类别叫 note",
        "size": 1236
    },
    {
        "content": "绝大多数情况下，我们写一个 Spider 会直接将需要的信息写在 Spider 里面，再不济也可能开个文件独立存储下需要的参数啥的，但这仅当 Spider 需求的这些信息是固定不变的情况下，而一旦需要从外部提交一些信息给它来动态调用，就需要用到传递参数了。\n先放两个官方文档链接\n Scrapy Spider arguments  使用 scrapy crawl 命令启动使用 -a 后面加参数名和参数值，这应该也就仅在测试时候使用下了。\n Scrapyd schedule.json  同样在 curl 中使用 -d 后面加参数名和参数值，也是测试时候会用到，可以简单理解它类似一个 form 表单向 URL 去 POST 数据，所以使用 requests 来接这个接口的话，就是：\nresp = requests.post(url=url, data=data) 这么说，那就是往这个 data 数据里面根据需求不断增加字段名和字段值就行了么，嗯，理解是这么理解，貌似也没啥问题，反正加了什么就在 Spider 那边同样根据字段把值提取出来就可以了，就这样可以了。\n不过，还是要说下，不断增加参数以及不断增加维护提取值的逻辑，字段数量多起来了，有点烦人呢。\n还有哦，刚为啥说把它简单理解为 form 表单呢，因为它的参数只支持字符串啊：\nKeep in mind that spider arguments are only strings. The spider will not do any parsing on its own. 那要是想提交点稍稍复杂点的数据咋办？\n我的解决方案是：把所有的自定义的参数都先放到一个 dict 里面去，然后用 json.dumps 处理下，这样把它这整个整体作为一个参数放进 data 里面提交过去，至于 Spider 那边就同样用 json.loads 反向处理下这一个字段值，这样很简单就拿到全部自定义参数了，无论它有多少，无论它怎么变化多端，就都好说了，反正你自定义的，全部都在这里面。\n至于这个参数名叫啥是最好，我也不太完全确定，暂时用了一个 s 来表示。\n通过 API 来启动 Spider 的话，又能传递你想要的参数进去，可扩展性就好很多了。\n",
        "date": 1530748800,
        "objectID": "758ba898a5fe58379557da86a735bbad",
        "relpermalink": "/python/2018-07-05-%E7%BB%99-scrapy-%E7%9A%84-spider-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/",
        "section": "python",
        "title": "给 Scrapy 的 Spider 传递参数",
        "size": 1976
    },
    {
        "content": "我上次测试如何正常在微信文章中正常显示代码块，时间是 5 月 5 号。\n很快是不是，苹果开发者大会也就快要开始了，为啥关注这个呢，因为，希望有新的手机和笔记本，虽然现在不买，还是希望它多更新，一个产品，多出几代，就成熟了。毕竟呢，如果是想要吃第一口热豆腐，是要付出代价的，还是规规矩矩做个稍微不那么发烧友的用户吧。\n你问我，干嘛要一直想着这些好东西，随便一般般的凑合用着不也行么？\nNO！是不是得凑合，要看情况。比如，吃饭的家伙就不能凑合。\n不知不觉，我在本机启动了至少 30 个服务，同事有时问我，你都到底开了些啥，我说，比如：\n 数据库要有吧，MySQL 肯定少不了，MongoDB 也要吧，Redis 你能缺么，与工作密切相关的配套基础设施，本地自然要跑一份起来。 Web 服务器，API 的服务，对吧。 Nginx 这种东西，本地也自然不能少（这货非常地不耗资源）。 还有数据处理各种配套的周边服务，比如数据对接、任务系统等等，无论简单与复杂，都至少要本地测试通过了才能上吧。 然后自己拿来玩的起码十来个吧，拿来学习的十来个吧，等等各种  随便几十个项目搭起来，完全不用凑数。\n干嘛要全部跑起来？需要的时候再临时启动不行么？\n不行！你知道销售漏斗原理么，不知道啊，那听说过网页页面每多一次操作就流失 30% 用户么？对于日常开发，以及学习，也是同理，需要持续做的事情就是：不断减少操作步骤，降低任务启动门槛。\n只有手指跟得上脑袋，才能有效完成任务。\n可这样呢，好是好，但问题来了，这电脑它吃得消么？你风扇咋还响呢……\n这个问题还确实是个困扰。\n跑的任务多了，自然就会给 CPU 和各个组件带来很大的压力，我也无法忍受风扇狂转起来的声音。\n我曾以为跑在 Docker 里面的这几十个服务会导致很大压力，从而造成风扇狂转，但是事实是，它们一点都不。除去个别的几个服务已经确定是极其耗资源的类型，同时又不是必须，所以不会日常都开之外，其它的，比想象中的资源消耗低得多，有的可以几乎忽略不计。\n我开始开始注意到底是谁在触发风扇，或者说风扇转起来只是表现，消耗 CPU 和磁盘与内存等才是原因。\n系统有个工具叫“活动监视器”，能耗选项卡直接列出能耗指数，排序下就知道是谁在捣鬼。\n 微信电脑版，当消息记录很多存储空间很大时，会直接导致能耗飙高。我发现它很意外，我一直没太仔细看明白能耗数据的正常值应该是多少，但是当我尝试清理完存储空间时，才知道它应该是 0-5 之间才正常。至于它为什么会如此耗能，应该是跟它软件设计基础逻辑有关吧，啥都要本地存。 惠惠购物助手，这是升级 Chrome 遇到的，升级到 67 版本后，Chrome 就一直狂飙到 100 多，无意间尝试干掉某个进程，却发现提示这个助手被干掉了，原来，竟然是这个插件影响了。删掉删掉。 微信后台编辑器页面，这个有点诡异，如果新开一个页面，会飙，但是干掉进程之后再刷新，就没事儿，有点诡异。浏览器的细节原理就不懂了，希望它们的开发去干活吧。  我原以为的 Docker 是主因，由于我开的服务较多的缘故，它确实处于能耗首位，所以如果出门在外，关掉它可以保命续航，但是它始终不会飙到能耗 100+ 这么可怕，平常还是很安静的。\n同样被我以为是主因之一的 Parallels 也最终确认并不是，只要虚拟机里面没有跑耗能的任务，它，也就没啥事。\n嗯，虚拟机里面开几个 Excel 进行操作时，确实会飙。\nAdobe PS，曾经好像会，后来发现也不会了，可能更新后兼容更好了。\n照片.app 有时候开着如果有新照片同步就会。\n大概就这些。\n如果是台式机就从不会去在意这个对吧。\n如果是 Windows 或许也不会，反正都一直响着。\n呃……\n勉强放点代码块，看看效果：\nitems = [6, 1, 4, 5, 4, 3, 8, 6] new_items = [] for item in items: if item not in new_items: new_items.append(item)",
        "date": 1528070400,
        "objectID": "400006022f561bb4164cf5c96d2b4798",
        "relpermalink": "/post/2018-06-04-%E8%B0%81%E5%9C%A8%E5%8A%A8%E6%88%91%E7%9A%84%E9%A3%8E%E6%89%87/",
        "section": "post",
        "title": "谁在动我的风扇",
        "size": 3422
    },
    {
        "content": "绝大多数的静态网站生成工具，无论是从 Markdown 文件还是 rST 格式的文件，甚至其它格式的文件，基本原理就是：利用一种面向用户友好的文本格式，通过工具处理为 HTML 格式，例如用户使用 Markdown 撰写文章，Hugo 帮忙处理为 HTML 文件。而后拿到静态的 HTML 文件则抛给例如 Nginx 这种 Web 服务器去提供服务即可。\n而处理的过程，则需要有按一定规则进行，例如标题与 URL 如何处理，文章日期如何处理，是否支持草稿，生成的网站页面列表如何排序，图片如何插入并显示等等。\n这里我取“如何编写带图片的文章”这个需求来说明下我的使用方案。\n其实如果仅仅只是文字内容，一篇文章一个 Markdown 文件，Hugo 以及大多数其它工具都会利用文件名来生成一个文件夹，而后此文件夹下面则会放入一个 index.html 文件。\n这是为啥呢，因为类似 Nginx 这种 Web 服务器，它的基本逻辑就是去某个文件夹下寻找 index.html 文件，而如果同时你又有提供文件名称，它则会去寻找对应的文件名。\n如果自己启动一个 Nginx 服务的话，有时候你会需要用到下面这段代码：\ntry_files $uri $uri.html $uri/index.html index.html; 所以这里其实可以看到，$uri 这个东西，要么指一个文件，要么指一个文件夹。\n如果你页面上有插入图片或者其他资源文件，那么你要么可以指定完整的文件路径地址，要么，就可以直接放到某个文件夹下面，与 index.html 平级，这样 index.html 引入的文件都可以是相对于当前页面所在文件夹的路径即可。\n这就是服务器方面的逻辑。\n下面是本地编写时候的逻辑。\n我使用的 Markdown 编辑器是 Typora，虽然它 bug 不断，修了一个又有另一个，但目前并没有其它任何一个编辑器能让我放弃它。\n它的实时编辑并渲染的功能，打出来任何一二三级标题和列表与段落，立马就显示为漂亮的效果，这才是一个内容编辑器应有的优秀视觉效果。\n而如果我插入一张图片，它则会立即渲染显示，我能立即看到效果。它插入图片所生成的 Markdown 内容一般会是这样的：\n![IMG_6004](IMG_6004-4755009.jpg) 这足够简单了，有插入菜单可以操作，如果你知道文件名，也可以自己写成这样，它就能渲染给你看。\n但是，有个问题。\n如果你的图片是放在某一个地方的，比如全部都在一个 static/img 文件夹下面，那这就有个问题。可能对与 Hugo 这样的工具最终渲染完成的网页是能显示图片的，但是你本地的编辑器，却不一定能显示出来，因为它没有能力去更高级文件夹去寻找文件，相对的它只能去自己的的子级文件夹去寻找文件。\n我曾经也是这么整理文件的，图片的归图片，文章的归文章，如果文件与图片不够多，是没有问题的，然而一旦文章和图片多了起来，需要考虑的问题就有了：图片是否最终到网站是能正常显示的（路径对不对），图片名称是否要改一改（万一文件名冲突就乱了）等等问题。\n所以现在呢，我所使用的方案就是：\n如果是要插入图片的，就建一个以文章名称命名的文件夹，里面放一个 index.md 文件，图片等文件就也放当前文章这个文件夹里面即可。\n这样，既能保证本地编辑是能实时渲染，也能保证最终呈现是正确无误的，而工作环境仅需要考虑当前文件夹，不用翻来覆去地寻找和核对。\n而如果是不需要插入图片的文章，依然还是一个以文章名称命名的 .md 文件即可。\n如果需要转移文章到新的目录，或者是寻找一个图片，都无需担心太多，直接操作，以文件夹为管理核心即可。\n这便是我的内容资源管理方案，很不错了。\n废话这么多，还是不如放一个文件夹路径图来的有视觉感：\n. ├── about │ ├── img │ │ ├── Jeremy.jpg │ │ └── qrcode_for_jeremyyincom_1280.jpg │ └── index.html ├── post │ ├── 2018-01-11-关联了两款小程序.md │ ├── 2018-02-05-一款小小的物流数据产品.md │ ├── 2018-03-19-现已加入 Algolia 搜索服务.md │ ├── 2018-04-13-我是如何搞砸了本站搜索服务的.md │ ├── 2018-04-18-小站构建工具已成功切换到 Hugo.md │ ├── 2018-04-19-开始翻译一个文档：Saleor.md │ ├── 2018-04-22-Saleor 初稿已翻译完成.md │ ├── 2018-04-26-今天全是干货 │ │ ├── IMG_5991-4755089.jpg │ │ ├── IMG_5997-4755064.jpg │ │ ├── IMG_5998-4755103.jpg │ │ ├── IMG_5999-4755051.jpg │ │ ├── IMG_6001-4755073.jpg │ │ ├── IMG_6002-4755080.jpg │ │ ├── IMG_6003-4755030.jpg │ │ ├── IMG_6004-4755009.jpg │ │ └── index.md │ ├── 2018-05-02-从 Jekyll 到 Hugo 的一些细节.md │ └── 2018-05-03-Hugo 的文件管理方案.md ├── python │ ├── 2016-06-28-给一个列表去重复却又要保留顺序.md │ ├── 2016-12-23-if True or if not True.md │ ├── 2017-06-14-造个轮子.md │ ├── 2017-09-02-努力投身 Python 3 的怀抱.md │ └── 2018-04-27-给一个列表去除重复数据的最原始方法.md └── saleor ├── architecture │ ├── 20_money.md │ ├── 21_products │ ├── 22_thumbnails.md │ ├── 23_stock.md",
        "date": 1525305600,
        "objectID": "8a11a7a73a0f38f572db96112c71b62d",
        "relpermalink": "/post/2018-05-03-hugo-%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/",
        "section": "post",
        "title": "Hugo 的文件管理方案",
        "size": 5208
    },
    {
        "content": "这篇是早些时候弄完 Hugo 就可以写了的，不过事事匆忙，就给搁置了。\n第一个细节是，类别，也叫目录或分类，无论是 Jekyll 还是 Hugo 它们使用的都是 categories 这个单词来处理类别。\nJekyll 直接在每一篇文章里面的 Front Matter 里面标记这篇文章属于哪个类别，当然，你也可以标记多个，这点从程序的角度来看，蛮合理的，类似于数据库的设计逻辑。但是，对于内容维护者来说，用一个很有意思的词来说，就是它不够 for Humans，意思就是这样的设计，不是为人类而设计的，不是站在人类的角度去思考问题的。不太确定 Jekyll 现在是否支持以文件夹来分类文件了，不过已经成功切换到 Hugo 了。\n所以，切换到 Hugo 的主要原因其一就是这个内容维护的方式问题。现在，所有文章都归属它们唯一的文件夹里面，如果哪天想修改下类别，就修改文件夹的名称即可，So easy。\n有人可能会提到 Tags，是的，一篇文章可能会有好几个 Tag 需要标记，这就随便你文章里面标记好了，我其实没特别的喜好 Tag 这个功能，随意贴标签？没有的事儿。\nHugo 还有一个更特殊的站点目录组织方式，叫 Taxonomies，意义上和 categories 差不多，不过有它特别的地方，暂时我也不想整复杂的，你有兴趣可以了解下，看上去还挺不错的。\n第二个细节，是搜索服务。\n切换到 Hugo 后，原使用的 jekyll-algolia 工具就废弃了，而 Algolia 方面则并未针对 Hugo 给出指导性的文档可供参考。\n虽然有些麻烦，不过了解了一番 Algolia 的 API 文档，以及参考了一篇来自于 Forestry 的它们是如何接入 Algolia 搜索的文章之后，解决了如何生成索引数据，然后上传更新的部分没有使用文章里面的东西，而是使用了 Algolia 的 Python API 进行接入，简单的不像样子。\n我取代码里面核心的部分出来：\nfilename = &#39;public/algolia.json&#39; rows = json.load(open(filename)) print(&#39;update algolia index&#39;) client = client_for_admin() index = client.init_index(INDEX_NAME) rows_ids = [row[&#39;objectID&#39;] for row in rows] all_ids = get_all_objectID(INDEX_NAME) ids_to_delete = list(set(all_ids) - set(rows_ids)) index.delete_objects(ids_to_delete) index.save_objects(rows) # index.set_settings({&#34;customRanking&#34;: [&#34;desc(date)&#34;]}) index.set_settings({&#34;searchableAttributes&#34;: [&#34;title&#34;, &#34;content&#34;]}) index.set_settings({&#39;attributesToHighlight&#39;: [&#34;title&#34;, &#34;content&#34;]}) index.set_settings({&#39;attributesToSnippet&#39;: [&#39;title&#39;, &#39;content:120&#39;]}) index.set_settings({&#39;highlightPreTag&#39;: &#39;&lt;em class=&#34;ais-Highlight&#34;&gt;&#39;, &#39;highlightPostTag&#39;: &#39;&lt;/em&gt;&#39;}) print({&#39;delete&#39;: len(ids_to_delete), &#39;save&#39;: len(rows)}) 而 algolia.json 则是这样的格式（内容太多就用 … 替代了）：\n[ { &#34;content&#34;: &#34;啥也不说，先看代码\\nitems = ...&#34;, &#34;date&#34;: 1524787200, &#34;objectID&#34;: &#34;e79a32cd1ebfc917af419cc006e390e8&#34;, &#34;relpermalink&#34;: &#34;/python/2018-04-27...&#34;, &#34;section&#34;: &#34;python&#34;, &#34;title&#34;: &#34;给一个列表去除重复数据的最原始方法&#34; }, { &#34;content&#34;: &#34;公司一个产品正式...&#34;, &#34;date&#34;: 1524700800, &#34;objectID&#34;: &#34;eddc4a4cfeda246ccc3b2334a0df1c75&#34;, &#34;relpermalink&#34;: &#34;/post/2018-04-26...&#34;, &#34;section&#34;: &#34;post&#34;, &#34;title&#34;: &#34;今天全是干货&#34; } ] 而关于 Algolia 的细节，有几个设置参数是值得提及的：\n searchableAttributes 与 attributesToHighlight，这两个无需多说，照着设置就好了。 attributesToSnippet，这个是值得重点说道的，为啥呢，因为它直接解决了一个关键问题：当搜索关键词时，只返回关键词所在的部分上下文，而不是返回整个文章，这样，在搜索结果列表就显示的是搜索出来的上下文，而你则可以自定义你想要的上下文长度是多少。曾经在 jekyll-aloglia 的逻辑中，它将文章切分为好多个碎片的这个极其不合理的操作模式也就不需要了（30 篇切出了近 500 条数据，那一千篇要切多少份&hellip;）。 highlightPreTag，这个是配合 CSS 高亮代码的设置，我从 Hugo 切换过来后，接入 Algolia 开始死活不给显示高亮词，我很纳闷，后来才思考是不是哪里设置不对，果然让我找到我自己更新的索引数据当中缺失了这个设置。当然现在我细读文档发现，它在查询的时候也可以设定，这也是一种方式了。  所以除了无法知晓 jekyll-algolia 的作者为什么要将文章进行切分存储之外，还有一些更深入的细节，可能需要自己去探索了。\nHugo 是个很好的 Markdown 网页生成工具，Algolia 也是个非常好的站内搜索服务提供商，GitHub 是个很好的静态网页托管服务提供商，需要感谢这么多人和公司开发并提供了这么多的免费又好用的服务和工具。\n",
        "date": 1525219200,
        "objectID": "c9725323d1048c061fa2667c19b3a641",
        "relpermalink": "/post/2018-05-02-%E4%BB%8E-jekyll-%E5%88%B0-hugo-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/",
        "section": "post",
        "title": "从 Jekyll 到 Hugo 的一些细节",
        "size": 6126
    },
    {
        "content": "啥也不说，先看代码\nitems = [6, 1, 4, 5, 4, 3, 8, 6] new_items = [] for item in items: if item not in new_items: new_items.append(item) new_items:\n[6, 1, 4, 5, 3, 8] 这应该是给一个列表去除重复还保留顺序的最兼容的办法了，为啥叫最兼容，意思是绝大多数情况下你按这个写法去操作，无论列表里面是什么东西，它都能很好地帮你处理成功。\n比如，列表里面不是简单的数字或字符，而是一个一个的字典（对象），这也是可以的。\nitems = [ {&#39;age&#39;: 6}, {&#39;age&#39;: 1}, {&#39;age&#39;: 4}, {&#39;age&#39;: 5}, {&#39;age&#39;: 4}, {&#39;age&#39;: 3}, {&#39;age&#39;: 8}, {&#39;age&#39;: 6}] new_items = [] for item in items: if item not in new_items: new_items.append(item) new_items:\n[{&#39;age&#39;: 6}, {&#39;age&#39;: 1}, {&#39;age&#39;: 4}, {&#39;age&#39;: 5}, {&#39;age&#39;: 3}, {&#39;age&#39;: 8}] 而之前有种利用 OrderedDict 进行操作去重复并保留顺序的方法，则不适用于这种包含多个字典的情况。\n为啥有时候会偏爱 OrderedDict 这种方法呢，因为：代码行数和思考方式，如果能有种方法可以快速帮你做到，自然是选快捷的。而且，在实际情况中，你可能需要在一个环节同时面对十几个字段的去重复操作，这时候能有一种内建的方法能支持你快速实现并让代码结构很流畅，是很辛福的事情。\n当然，也可以把上面的办法独立写个函数，这样就可以到处调用了。\nA_items = [ {&#39;age&#39;: 6}, {&#39;age&#39;: 1}, {&#39;age&#39;: 4}, {&#39;age&#39;: 5}, {&#39;age&#39;: 4}, {&#39;age&#39;: 3}, {&#39;age&#39;: 8}, {&#39;age&#39;: 6}] B_items = [ {&#39;quantity&#39;: 60}, {&#39;quantity&#39;: 10}, {&#39;quantity&#39;: 40}, {&#39;quantity&#39;: 50}, {&#39;quantity&#39;: 40}, {&#39;quantity&#39;: 30}, {&#39;quantity&#39;: 80}, {&#39;quantity&#39;: 60}] def select_distinct(items): new_items = [] if not items: # 对于提供的数据不是符合数据结构的情况，可以根据具体情况来判断并修改返回空list或者是提示报错 return new_items for item in items: if item not in new_items: new_items.append(item) return new_items my_A_items = select_distinct(A_items) my_B_items = select_distinct(B_items) my_A_items:\n[{&#39;age&#39;: 6}, {&#39;age&#39;: 1}, {&#39;age&#39;: 4}, {&#39;age&#39;: 5}, {&#39;age&#39;: 3}, {&#39;age&#39;: 8}] my_B_items:\n[{&#39;quantity&#39;: 60}, {&#39;quantity&#39;: 10}, {&#39;quantity&#39;: 40}, {&#39;quantity&#39;: 50}, {&#39;quantity&#39;: 30}, {&#39;quantity&#39;: 80}] 这样，你可能不止两个三个需要处理，有时候可能是十几个，这样代码结构上的流畅性就很可观了。\n",
        "date": 1524787200,
        "objectID": "e79a32cd1ebfc917af419cc006e390e8",
        "relpermalink": "/python/2018-04-27-%E7%BB%99%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%80%E5%8E%9F%E5%A7%8B%E6%96%B9%E6%B3%95/",
        "section": "python",
        "title": "给一个列表去除重复数据的最原始方法",
        "size": 3892
    },
    {
        "content": " 一年写了 30 几个小产品接口，该想想是不是代码太乱了。Django 说十几行代码完成增删改查，可能培训机构只顾着拉新了吧，MVC 构架可能确实简单。\n面向对象听了无数遍，可一次也没创建过自己的对象，一般都用别人现成的对象，还得看别人告诉你怎么用。\n要创建自己的对象了。写爬虫和写爬虫，不一样就是不一样的，Hello World 跑起来简单，可 Demo 和生产环境那是两码事儿。\n还有，需求一直在变，你知道的吧？\n这两周代码写的慢，把一个东西重构了，自己迷糊着创建对象。\n所以，一个人或一个环境未来究竟会如何，全看它过去做过啥，在哪里进行发力。\n今天全是干货你懂的撒。你买多一点，我就回血多一点。\n果然还是买买买才会令我兴奋不已，其它的嘛，抛开不谈也罢。\n深入剖析Kubernetes - 张磊 从0开始学微服务 - 胡忠想 技术管理实战36讲 - 刘建国 Go语言核心36讲 - 郝林 邱岳的产品实战 - 邱岳 深入拆解 Java 虚拟机 - 郑雨迪 持续交付36讲 - 王潇俊 软件测试52讲 - 茹炳晟 React实战进阶45讲 - 王沛 机器学习40讲 - 王天一 从0开始学游戏开发 - 蔡能 零基础学Python - 尹会生 趣谈网络协议 - 刘超 朱赟的技术管理课 - 朱赟 赵成的运维体系管理课 - 赵成 深度学习应用实践60讲 - AICon人工智能专家团 人工智能基础课 - 王天一 AI技术内参 - 洪亮劼 技术与商业案例解读 - 徐飞 左耳听风 - 陈皓 邱岳的产品手记 - 邱岳 技术领导力300讲 - TGO鲲鹏会 从0开始学架构 - 李运华 硅谷产品实战36讲 - 曲晓音 9小时搞定微信小程序开发 - 高磊 ",
        "date": 1524700800,
        "objectID": "357a1c0fd20387a508e706cca377d5f2",
        "relpermalink": "/advertisement/geek-time/",
        "section": "advertisement",
        "title": "极客时间",
        "size": 1518
    },
    {
        "content": " 《上手》，是由许岑打造的一个学习平台，借由凡事以上手为目标去学习的理念，打造一系列内容跨度较大的各种课程。\n你洗头可能从没洗干净过 - 梁子 ",
        "date": 1524614400,
        "objectID": "c0c6c7265a92b98f9dd2c70504d6c9a9",
        "relpermalink": "/advertisement/becoming/",
        "section": "advertisement",
        "title": "上手",
        "size": 218
    },
    {
        "content": "赶在周末结束之前，把 Saleor 的文档初步“翻译”完成，干嘛打个引号，说到底还是心虚，哈哈。\n毕竟是借助了绝大多数 Google 翻译的内容，而我就好像是一个审稿者，一句一句看一遍，觉得好就用了，觉得实在是不行就才按自己理解的来，所以，能说有功夫在的，就只能是这部分了。\n搜索了下，由于 Python 圈我个人猜测可能基本上不屑于（这里需要给个？号）整一些购物车程序系统啥的，导致搜索一圈下来没看到几个可以接近于“开箱即用”的产品或是听上去使用较多的集成方案，导致在电商领域它的生态好像并不是发展的活跃。\n这也可能是我个人的误解。\nSaleor 是我所通过搜索查询到从看 Demo 和文档都觉得它的集成度（开箱可用程度）和可定制化说明做的较好的一个方案，也看到几乎没有人做中文文档的翻译，既然我想深入了解，那就从翻译开始吧，顺便也积累下可用的中文资料。\n如果有缘人能看到，也是一种幸运了。\n",
        "date": 1524355200,
        "objectID": "f443b421dff5ec161f288f581fa5043b",
        "relpermalink": "/post/2018-04-22-saleor-%E5%88%9D%E7%A8%BF%E5%B7%B2%E7%BF%BB%E8%AF%91%E5%AE%8C%E6%88%90/",
        "section": "post",
        "title": "Saleor 初稿已翻译完成",
        "size": 868
    },
    {
        "content": "这篇文章要在10分钟内写完。\n今晚上开始着手翻译关于 Saleor 的文档，它是一个购物车程序，说它是个程序其实到也不完全是，准确说应该是它提供了一个整体参考方案，选用几个先进的不同产品进行组合，搭建起这么一个东西，相比其它一般性的购物车程序，我第一眼看过去就喜欢上它，demo 足够漂亮，响应速度也非常不错。\n再仔细看过了它所使用的功能组件和工具，都走在技术发展前沿，这点很不错，这表示你是在为未来而努力。\n我英文不咋滴，不过经过这一两年的接触，技术类的英文文档基本能看懂个大概意思，个别不懂的借助下词典工具或者翻译工具，比如系统自带词典和 Google 翻译。\n如今这个时代，语言不会是最大的障碍。\n今天完成了前面一些些，已经在小站放出来了，有兴趣可以看看，翻译可能存在一些问题，欢迎拍砖。\n好了，到这就发吧。\n",
        "date": 1524096000,
        "objectID": "9b7a7b469448ef9ea79b19c35b0b27b9",
        "relpermalink": "/post/2018-04-19-%E5%BC%80%E5%A7%8B%E7%BF%BB%E8%AF%91%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3saleor/",
        "section": "post",
        "title": "开始翻译一个文档：Saleor",
        "size": 790
    },
    {
        "content": " Saleor 使用 Prices 和 django-prices 库去存储、计算和显示金额、价格与范围。\n默认货币 所有价格都输入并存储在由 [DEFAULT_CURRENCY 设置] 控制的单一默认货币中。Saleor 可以以用户本地货币显示价格 （参阅 [Open Exchange Rates integration]），但所有采购均以默认货币收取。\nWarning\n货币不存储在数据库中。在生产环境中更改默认货币不会重新计算任何现有订单。所有数字将保持不变，并且会被错误地显示为新货币。\nMoney 和 TaxedMoney 在 Saleor 的代码库中，金额存在 Money 或 TaxedMoney 实例。\nMoney 是以特定货币表示金额的类型：100 USD 是由 Money(100, &lsquo;USD&rsquo;) 表示。这种类型不包含对商业有用的任何附加信息，但是与 Decimal 不同，它实施保护和检查以计算和比较货币价值。Money amounts 使用 MoneyField 存储在 model 上，MoneyField 提供货币和储值金额的自己的安全检查。如果您需要使用 Money 对象的 Decimal （十进制数字），您可以在 amount 属性中找到它。\nProducts （产品）和 shipping methods prices （运输方式价格）使用 MoneyField 进行存储，并假定为 gross amounts （总额）。然后使用 TaxedAmount（net = item.price，gross = item.price）方法将这些金额转换为 TaxedMoney 对象，然后在解决项目的最终价格（税前和折扣前）进行转换。\nNote\n未来，Saleor 将支持为商店管理员设置更改此方法以使用净值（net values）的方式，如果这更符合他们的业务。\nTaxedMoneyRange 有时侯，由于它的变体定义了不同于基准价格的自定义价格，产品可能以不止一个价格出售。对于这样的情况，Product 额外定义了 get_price_range 和 get_gross_price_range 方法，可以返回 TaxedMoneyRange 对象，用于定义启动（start）和停止（stop）属性的最小（minim）和最大（maximum）价格。这个对象然后可以被 UI 使用，使得在产品有不同的变体的情况下显示价格为 “10 USD” 或 “from 10 USD”。\nTaxedMoneyRange 还用于显示其他货币范围，例如最小和最大成本（min and maximum cost）以及仪表盘中产品变体的保证金（margin）。\n",
        "date": 1524096000,
        "objectID": "00a8f01d0123fa6e9725cb9f96c6191d",
        "relpermalink": "/saleor/architecture/20_money/",
        "section": "saleor",
        "title": "Saleor 20: 架构 - 处理钱的金额",
        "size": 2378
    },
    {
        "content": " 在为您的商店填充产品之前，我们需要介绍 3 种产品概念：产品类型 product types ，产品 products ，产品变体 product variants 。\n概述 设想你有一家书店。 你的其中一个产品 products 一本名为“Saleor 简介”的书。\n这本书的封面有分为硬壳和软壳，所以会有两种产品变体 product variants 。\n封面类型是在我们的商店中创建单独变体的唯一属性，因此我们使用“Book”作为产品类型 product type ，为它启用变体并使用“Cover type”作为变体属性 variant attribute 。\nClass Diagram 产品变体（Product Variants） 变体是你店里最重要的物品。所有购物车和库存操作都使用变体。即使产品没有多种变体，商店也会在后台创建一个。\n产品（Products） 介绍几个产品变体 product variants 的常见细节。当商店显示类别视图时，列表中的项目是不同的产品 products 。如果变体没有重写属性（例如：价格），则从产品 products 中获取默认值。\n available_on  在此日期之前，该产品未在店面中列出，且用户不可用。\n is_featured  特色产品显示在首页\n产品类型（Product Types） 将类型看作您的产品的模板。多个 产品 products 可以使用相同的产品类型 product type。\n product_attributes  所有 产品变体 product variants 之间共享的属性。例如：发布者，所有书籍变体都由同一家公司出版。\n variant_attributes  这是什么区别不同的 变体 variants 。例如：封面类型，你的书可以用硬或软的封面。\n is_shipping_required\n指示是否需要交付采购。例如：数字产品，您将不会使用 DHL 发送 MP3 文件。\n has_variants\n如果您的 产品 product 没有多个变体，或者您想为其中的每个 变体 创建单独的 产品 ，请将其关闭。该选项主要简化仪表板中的产品管理。一个产品会自动创建一个 变体 。\n  Warning\n更改产品类型会影响此类型的所有产品。\nWarning\n如果有这种类型的产品，则无法删除产品类型。\n属性（Attributes） 属性 可以帮助您更好地描述您的产品。此外，可用于过滤类别视图中的项目。\n有两种类型的 属性 ：选择类型（choice type）和文本类型（text type）。如果您不进行指定，则属性默认是文本类型。\nExamples  Choice type: Colors of a t-shirt (for example ‘Red’, ‘Green’, ‘Blue’) Text type: Number of pages in a book  Example: Coffee 你的商店出售来自世界各地的咖啡。客户可以订购 1kg，500g 和 250g 包装。订单由快递员运送。\nAttributes\n   Attribute Values     Country of origin Brazil, Vietnam, Colombia, Indonesia   Package size 1kg, 500g, 250g    Product type\n   Name Product attributes Variants? Variant attributes Shipping?     Coffee Country of origin Yes Package size Yes    Product\n   Product type Name Country of origin Description     Coffee Best Java Coffee Indonesia Best coffee found on Java island!    Variants\n   SKU Package size Price override     J001 1kg $20   J002 500g $12   J003 250g $7    Example: Online game items 你有很多精选的网络游戏物品。每个项目都是独特的，重要细节包含在描述中。购买的商品直接发送到买家帐户。\nAttributes\n   Attribute Values     Game Kings Online, War MMO, Target Shooter   Max attack —    Product type\n   Name Product attributes Variants? Variant attributes Shipping?     Game item GameMax attack No — No    Products\n   Product type Name Price Game Max attack Description     Game item Magic Fire Sword $199 Kings Online 8000 Unique sword for any fighter. Set your enemies on fire!   Game item Rapid Pistol $2500 Target Shooter 250 Fastest pistol in the whole game.    ",
        "date": 1524096000,
        "objectID": "ec4101dcbda666302c9ede50982f7221",
        "relpermalink": "/saleor/architecture/21_products/",
        "section": "saleor",
        "title": "Saleor 21: 架构 - 产品结构",
        "size": 4760
    },
    {
        "content": " Saleor 使用 VersatileImageField 替换了 Django 的 ImageField 。出于性能原因，在非调试模式下，缩略图由工作者的任务系统预先生成，在保存实例后触发。访问丢失的图像将导致404错误。\n在调试模式下，按需生成缩略图。\n手动生成产品缩略图 为所有 ProductImage 实例创建缺失的缩略图。\n$ python manage.py create_thumbnails 删除图像 Image 实例不会自动删除图像格式，主图像也不会自动删除。有关删除图像的更多信息，请参见 VersatileImageField 文档\n",
        "date": 1524096000,
        "objectID": "3c46c64b656f147feb32ee1e4a737dac",
        "relpermalink": "/saleor/architecture/22_thumbnails/",
        "section": "saleor",
        "title": "Saleor 22: 架构 - 缩略图",
        "size": 634
    },
    {
        "content": " 每个产品型号都有一个库存单位（SKU）。\n每个变体保存了关于“数量”的相关信息，总库存数量 quantity 包括分配给已经生成的订单的已分配数量 quantity allocated 和可用数量 quantity available 。\nExample: 有五盒鞋子。其中三个已经出售给客户，但尚未处理发货。总库存数量 quantity 为 5，已分配数量 quantity allocated 为 3，可用数量 quantity available 为 2。\n每个变体也有一个*成本价格*（您的商店必须支付才能拿得到货的价格，可以理解为采购价）。\n产品可用性（Product Availability） 如果一个*变体*还有未分配的库存数量，则它就表示是*有货*的。\n可订购的最高数量是产品变体中的可用数量 quantity available。\n为新订单分配库存（Allocating Stock for New Orders） 一旦下订单，完成每个订单行所需的数量立即标记为*已分配*。\nExample: 一位顾客又下了一盒鞋子的订单。总库存数量 quantity 是 5, 已分配数量 quantity allocated 现在就是 4 ，然后可用数量 quantity available 就变成了 1.\n发货后减少库存（Decreasing Stock After Shipment） 一旦交付组（可以理解为发货单）被标记为发货，这个发货单里面的每条记录所对应的产品变体将手头的数量和分配的数量都减少了出货的数量。\nExample: A 仓库的两箱鞋子被运送给客户。总库存数量 quantity 现在就是 3，已分配数量 quantity allocated 则变为 2，可用数量 quantity available 依然是 1。\n",
        "date": 1524096000,
        "objectID": "7c095b1adb8b78dd4b05de5b5b6edb2b",
        "relpermalink": "/saleor/architecture/23_stock/",
        "section": "saleor",
        "title": "Saleor 23: 架构 - 库存管理",
        "size": 1624
    },
    {
        "content": " 订单是在客户完成结账流程后创建的。订单对象本身仅包含客户订单的一些基本信息。\n履行（Fulfillment）（可以理解为发货与发货单） 履行代表一组带有相应跟踪编号的装运物品。履行是由商店经营者创建的，以便在所订购的订单中标记选定的产品已被履行。\n有两种可能的履行状态：\n NEW\n新创建履行的默认状态。\n CANCELED\n履行由商店操作员取消。这一行动是不可逆转的。\n  订单状态（Order statuses） 根据其履行情况，有四种可能的订单状态：\n UNFULFILLED\n没有与订单相关的履行或每一个履行都被取消。需要店铺操作员采取行动才能继续订单处理。\n可以理解为还未发货\n PARTIALLY FULFILLED\n有一些履行 FULFILLED 状态与订单有关。需要店铺操作员采取行动才能继续订单处理。\n可以理解为部分发货\n FULFILLED\n每个订单行都在现有履行中完成。订单不需要店铺经营者的进一步行动。\n可以理解为发货完成\n CANCELED\n订单已被取消。每个履行（如果有的话）都具有 CANCELED 状态。订单不需要店铺经营者的进一步行动。\n  还有 DRAFT （草稿）状态，用于从订单后台新创建并尚未发布的订单。这个操作一般用于客服售后流程。\n",
        "date": 1524096000,
        "objectID": "89b6c2772281bc4ad579ec3ddd4ce998",
        "relpermalink": "/saleor/architecture/24_orders/",
        "section": "saleor",
        "title": "Saleor 24: 架构 - 订单管理",
        "size": 1154
    },
    {
        "content": " 默认情况下，语言和语言环境是根据 Web 浏览器提供的首选项列表确定的。GeoIP 用于确定访问者的国家和当地货币。\nNote\nSaleor 使用 Transifex 协调翻译。如果您希望提供帮助，请前往 translation dashboard\n所有翻译都由社区处理。所有翻译团队都是开放的，欢迎所有人申请一种新语言。\n翻译（Translation） Saleor 使用 gettext 翻译。这是翻译软件的行业标准，也是翻译 Django 应用程序的最常用方法。\nSaleor 的店面和管理后台都准备好翻译。他们使用单独的翻译域名，可以单独翻译。所有翻译都提供准确的上下文描述，使翻译更容易。\n目前无法翻译数据库内容（如产品说明），但计划在未来版本中使用。\n本土化（Localization） 数据格式（Data formats） Saleor使用 Babel 作为 Unicode 的 CLDR 库的接口，以提供准确的数字和日期格式以及适当的货币名称。\n地址表格（Address forms） Google’s address format database 用于提供特定于语言环境的地址格式和表单。它还负责地址验证，因此您不必知道如何向中国递送包裹或阿拉伯联合酋长国是否使用邮政编码（他们不会）。\n货币转换（Currency conversion） Saleor可以使用货币汇率数据来显示访客本地货币的价格估算值。请参阅 Open Exchange Rates 以了解如何设置 Open Exchange Rates。\n电话号码格式（Phone numbers format） Saleor 使用 Google’s libphonenumber library 来确保提供的数字是正确的。您需要选择前缀并单独键入号码。无论选择哪个国家，您都可以输入属于任何其他国家/地区格式的电话号码。\n",
        "date": 1524096000,
        "objectID": "61dcae0101c788a1b806ddf16e8f7b66",
        "relpermalink": "/saleor/architecture/25_i18n/",
        "section": "saleor",
        "title": "Saleor 25: 架构 - 国际化",
        "size": 1674
    },
    {
        "content": "Saleor 有两种搜索机制。\n默认是使用 PotsgreSQL。这是一个相当通用的解决方案，不需要任何额外的资源。\n如果 Elasticsearch 服务器可用，则可以启用更复杂的搜索后端。Elasticsearch 提供了许多高级功能，例如提高查询的相关性或“more like this”的查询。查看 Elasticsearch官方网站，了解更多关于其功能的信息。请注意，启用Elasticsearch 后端目前不支持 Saleor 中的任何其他功能。\n有关安装和配置说明，请参阅 Elasticsearch。\n",
        "date": 1524096000,
        "objectID": "a65c4bb172e8e03be41424f27988b9b1",
        "relpermalink": "/saleor/architecture/26_search/",
        "section": "saleor",
        "title": "Saleor 26: 架构 - 搜索",
        "size": 592
    },
    {
        "content": " 支持的网关（Supported Gateways） Saleor 使用 django-payments 库来处理付款。\n默认配置使用*虚拟*后端。这意味着开发人员可以轻松模拟不同的付款结果。\n以下是支持的支付提供商列表：\n Authorize.Net Braintree Coinbase Cybersource Dotpay Google Wallet PayPal Sage Pay Sofort.com Stripe  请注意，此列表仅供参考。请咨询 django-payments documentation 以获得最新的列表和说明。\nNote\n所有付款后端默认使用沙盒模式。这对于开发非常有用，但确保在部署到生产服务器时使用生产模式。\n3-D Secure 3-D Secure 是一种卡保护协议，允许商家部分减轻欺诈责任。实际上，它大大降低了退款的可能性。\nSaleor 支持 3-D Secure 但是否使用取决于付款处理器和正在使用的卡。\n欺诈保护（Fraud Protection） 一些支付后端提供了自动欺诈保护启发式。如果此类信息可用，Saleor 会将其显示在订单管理面板中。\n授权和捕获（Authorisation and Capture） 部分支付后端支持预授权支付。详情请参阅 django-payments documentation。\n授权和捕获是一个两步过程。\n首先，资金被锁定在付款人的账户上，但不会转移到您的银行。\n然后根据提供商和卡的类型，您可能需要几天到一个月的时间才从卡上进行扣钱，金额不超过授权金额。\n当订单准备好后才能确定准确的价格时，这非常有用。如果您的企业更喜欢手动筛选企图欺诈的订单，这也很有用。\n使用预授权付款查看订单时，Saleor 将提供选项以捕捉或释放资金。\n退款（Refunds） 您可以针对所有收取的付款进行部分或全部退款。当您修改订单并删除 Saleor 将提供的物品时，系统会自动发出部分退款。\n",
        "date": 1524096000,
        "objectID": "fa79c1c2eae220671d87046a2b29d4a0",
        "relpermalink": "/saleor/architecture/27_payments/",
        "section": "saleor",
        "title": "Saleor 27: 架构 - 支付",
        "size": 1744
    },
    {
        "content": " *网站设置*模块允许您从管理后台更改常见的商店设置，如店铺名称或域名。通过从 SITE_SETTINGS_ID 变量中选择 pk 确定设置对象。\n情境处理器 感谢 saleor.site.context_processors.settings 您可以通过 settings 变量访问模板中的*网站设置*。\n",
        "date": 1524096000,
        "objectID": "b9854683d7ab200b2eee787a45d6d802",
        "relpermalink": "/saleor/architecture/28_settings/",
        "section": "saleor",
        "title": "Saleor 28: 架构 - 网站设置",
        "size": 382
    },
    {
        "content": " 设置自定义页面 您可以在后台管理的“页面”（Pages）菜单中设置页面，如“关于我们”或“重要通告！”。请注意，如果您不是管理员，则需要加入拥有相应权限的用户组。\n在店面中引用页面 如果您想要在店面中添加最近创建的页面的链接，则只需将以下代码放入：\n&lt;a href=&#34;{% url &#34;page:details&#34; slug=&#34;terms-of-service&#34; %}&#34;&gt;服务条款&lt;/a&gt; 在相应的模板中。\n",
        "date": 1524096000,
        "objectID": "3f7051b56aea9f80e1ee1dff9318b82d",
        "relpermalink": "/saleor/architecture/29_page/",
        "section": "saleor",
        "title": "Saleor 29: 架构 - 页面",
        "size": 552
    },
    {
        "content": "EditorConfig 是一个标准配置文件，旨在确保跨多种编程环境的一致风格。\nSaleor 的存储库包含一个 .editorconfig file 文件，它描述了我们的格式要求。\n大多数编辑器和IDE都直接或通过插件支持该文件。 请参阅 list of supported editors and IDEs 以获取相关说明。\n请确保您的编程环境尊重此文件的内容，并且您将自动获得正确的缩进，编码和行尾。\n",
        "date": 1524096000,
        "objectID": "7d41184e6db171884fce64efa139f281",
        "relpermalink": "/saleor/contributing/17_editorconfig/",
        "section": "saleor",
        "title": "Saleor 17: 参与我们 - 编辑器配置",
        "size": 482
    },
    {
        "content": " Python 始终遵循 PEP 8 ，但请记住，一致性非常重要。\nString Literals 优先使用单引号加双引号，除非字符串本身包含需要不必要地转义的单引号。\nWrapping Code When wrapping code follow the “hanging grid” format:\nsome_dict = { &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}some_list = [ &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;] Python是一种基于缩进的语言，我们相信漂亮，可读的代码比保存一行 git diff 更重要。 即使 Django 项目似乎鼓励这种编程风格，请避免使用括号，括号，方括号或悬挂逗号。下面这种是错误的做法：\nthis_is_wrong = { &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, } 请在括号后立即打破多行代码，并避免依赖精确数量的空格进行对齐，下面这种做法也是错误的：\nalso_wrong(&#39;this is hard&#39;, &#39;to maintain&#39;, &#39;as it often needs to be realigned&#39;) Linters 使用 isort 来维护一致的进口。\n使用 pylint 与 pylint-django 插件来捕获代码中的错误。\n使用 pycodestyle 确保您的代码符合 PEP 8。\n使用 pycodestyle 检查您的文档字符串格式是否正确。\n",
        "date": 1524096000,
        "objectID": "e2a81bc44ef7db687613aee2bf8bc2e9",
        "relpermalink": "/saleor/contributing/18_coding-style/",
        "section": "saleor",
        "title": "Saleor 18: 参与我们 - 编码风格",
        "size": 1546
    },
    {
        "content": " 为了保持一致的代码结构，我们在命名文件时遵循一些规则。\nPython Modules 试着让名字反映文件的功能。 如果可能的话，避免使用通用文件名，例如 utils.py.\nDjango Templates 使用下划线作为字词分隔符。\nStatic Files 使用破折号分隔单词，因为它们最终会成为 URL 的一部分。\n",
        "date": 1524096000,
        "objectID": "5430ac05b9c51dca1147f96ff8b87ffc",
        "relpermalink": "/saleor/contributing/19_naming/",
        "section": "saleor",
        "title": "Saleor 19: 参与我们 - 命名约定",
        "size": 398
    },
    {
        "content": " 使用Docker构建软件，您可以运行和测试代码，而无需担心外部依赖性，如缓存服务器和数据库。\nWarning\n以下设置仅用于本地开发。请参阅 Docker 以获取 Docker 在生产环境的使用说明。\n本地准备工作 在执行以下步骤之前，您需要安装 Docker 和 docker-compose 。\n要构建资源库，您需要 node 和 webpack module bundler\nWarning\n我们的配置公开了 PostgreSQL，Redis 和 Elasticsearch 端口。如果由于端口冲突而运行此 Docker 文件时遇到问题，可以从 docker-compose.yml 文件中删除关于 &lsquo;ports&rsquo; 的部分。\n用法  安装 JavaScript 依赖：  $ npm install  准备静态资源库 assets:  $ npm run build-assets  创建 email:  $ npm run build-emails  使用 docker-compose 创建容器：  $ docker-compose build  准备数据库：  $ docker-compose run web python manage.py migrate $ docker-compose run web python manage.py collectstatic $ docker-compose run web python manage.py populatedb --createsuperuser 这个 --createsuperuser 开关会使用 admin@example.com 创建一个管理员账户，密码设置为 admin\n 启动容器：  $ docker-compose up 默认情况下，应用程序以调试模式启动，将自动重新加载代码并配置为在端口 8000 上侦听。\n",
        "date": 1524096000,
        "objectID": "c4ce1e7980f4980b0025582af3413e89",
        "relpermalink": "/saleor/customization/08_docker/",
        "section": "saleor",
        "title": "Saleor 08: 开发定制 - 使用 Docker 进行开发",
        "size": 1708
    },
    {
        "content": "商店前端模版默认是基于 [Bootstrap 4\n你可以在 /templates/ 文件下找到全部文件。\n",
        "date": 1524096000,
        "objectID": "276f9e270abb2db0af0d1fe45fb0a324",
        "relpermalink": "/saleor/customization/09_templates/",
        "section": "saleor",
        "title": "Saleor 09: 开发定制 - 自定义模版",
        "size": 180
    },
    {
        "content": " 发送邮件 邮件是使用 Django-Templated-Email 进行发送的。\n自定义邮件模版 电子邮件模板在 templates/templated_email 中，它有两个子目录。 source 包含 *.email 和 *.mjml 文件，彼此相邻，按应用程序名称分组。 这些 MJML 文件被编译为 *.html 并放入 compiled 目录。\n在 *.email 中的普通电子邮件通过引用编译的 *.html 文件来包含 HTML 版本。\n编译 MJML 源电子邮件使用 MJML ，并且在使用之前必须编译为HTML。\n要编译邮件的话就运行命令：\n$ npm run build-emails",
        "date": 1524096000,
        "objectID": "9e8ec66ff258c0cddf803df828e6cd5d",
        "relpermalink": "/saleor/customization/10_emails/",
        "section": "saleor",
        "title": "Saleor 10: 开发定制 - 自定义邮件",
        "size": 682
    },
    {
        "content": "所有的静态资源文件都在 /saleor/static/ 的子目录下面。\n样式表是使用 Sass 写的，使用 postcss 和 autoprefixer 来支持跨浏览器兼容性。\nJavaScript 代码是按 ES2015 标准写的， 使用 Babel 进行转换和补充浏览器兼容性。\n一切都是使用 webpack module bundler 进行编译。\n最终生成的文件都输出到 /saleor/static/assets/ ，你不要手动去编辑它们。\nwebpack 会自动监测到本地文件的修改，这在开发过程中有非常大的好处。 在调试阶段，这同时开启非常有用的 source maps\nTo run webpack in watch mode run:\n$ npm start Warning\n使用上面这种方式创建的文件并不是完全可以在生产环境下直接使用的，要使用下面的命令进行操作：\n$ npm run build-assets --production",
        "date": 1524096000,
        "objectID": "8c6b816643cb8b7e1bb6b7a8e2770eee",
        "relpermalink": "/saleor/customization/11_frontend/",
        "section": "saleor",
        "title": "Saleor 11: 开发定制 - 自定义 CSS 和 JavaScript",
        "size": 930
    },
    {
        "content": " 管理依赖库 为了保证可重复安装，所有项目依赖性都使用 pip-tools 进行管理。 项目的直接依赖关系列在 requirements.in 中，并且运行 pip-compile 生成所有版本固定的 requirements.txt 。\n我们建议您使用此工作流程并在版本控制下保留 requirements.txt ，以确保所有计算机和环境都运行完全相同的代码。\n",
        "date": 1524096000,
        "objectID": "760e9e79398750947a4a339bd9136489",
        "relpermalink": "/saleor/customization/12_backend/",
        "section": "saleor",
        "title": "Saleor 12: 开发定制 - 编写 Python 代码",
        "size": 440
    },
    {
        "content": " 从 Transifex 获取翻译文件 首先要确保你已经安装了 Transifex 命令行客户端:\n$ pip install transifex-client 然后使用 pull 命令获取翻译文件:\n$ tx pull Note\n要为新创建的翻译建立目录你需要在使用 tx pull 命令的时候带上 --all 标志。\n编译消息目录 要想看到 Django 的翻译，这一步是必须要的.\n$ python manage.py compilemessages 提取消息进行翻译 这将使用代码中显示的消息更新英文文件。\n对于后端代码和模板：\n$ python manage.py makemessages -l en --extension=email,html,py,txt --ignore=&#34;templates/templated_email/compiled/*&#34; 对于 JavaScript 代码：\n$ python manage.py makemessages -l en -d djangojs --ignore=&#34;_build/*&#34; --ignore=&#34;node_modules/*&#34; ",
        "date": 1524096000,
        "objectID": "b4dec3beb11179f8c0cdcb9012e8e76e",
        "relpermalink": "/saleor/customization/13_i18n/",
        "section": "saleor",
        "title": "Saleor 13: 开发定制 - 国际化",
        "size": 1120
    },
    {
        "content": "在对代码进行任何永久更改之前，应确保它们不会破坏现有功能。\n该项目目前只包含很少的前端代码，因此测试套件仅涵盖后端代码。\n要运行后端测试，请使用 pytest:\n$ py.test 您还可以测试所有支持的 Django 和 Python 版本。 这通常只有在您想要将更改回送给 Saleor 时才需要。 要做到这一点，你可以使用 Tox:\n$ tox",
        "date": 1524096000,
        "objectID": "08b5034a352bbf96ca1fa1183aa8fc83",
        "relpermalink": "/saleor/customization/14_tests/",
        "section": "saleor",
        "title": "Saleor 14: 开发定制 - 运行测试",
        "size": 424
    },
    {
        "content": "商店附带一个可工作的 CircleCI 配置文件。 要使用它，请登录您的 CircleCI 帐户并启用您的存储库。\n",
        "date": 1524096000,
        "objectID": "b275d5a170104217c60de342fc909950",
        "relpermalink": "/saleor/customization/15_ci/",
        "section": "saleor",
        "title": "Saleor 15: 开发定制 - 持续集成",
        "size": 190
    },
    {
        "content": "Saleor 可以很好地与 PyPy 3.5 配合使用，并且在需要额外的性能时可以使用它。\n默认的 PostgreSQL 驱动程序与 PyPy 不兼容，所以您需要用基于 cffi 的驱动程序替换它。\n请参阅 psycopg2cffi 提供的安装说明。\n",
        "date": 1524096000,
        "objectID": "0f941782538ac14fa3fe58e865ee1d8c",
        "relpermalink": "/saleor/customization/16_pypy/",
        "section": "saleor",
        "title": "Saleor 16: 开发定制 - 与 PyPy 3.5 配合使用",
        "size": 326
    },
    {
        "content": "您需要先安装 Docker。\n在构建镜像之前，请确保您准备好了用于生产环境的所有前端资源文件：\n$ npm run build-assets --production $ npm run build-emails $ python manage.py collectstatic 然后使用 Docker 构建镜像：\n$ docker build -t mystorefront .",
        "date": 1524096000,
        "objectID": "0cf9aa84e3433ecbe4cb9ebfe7542cf7",
        "relpermalink": "/saleor/deployment/37_docker/",
        "section": "saleor",
        "title": "Saleor 37: 部署 - Docker",
        "size": 454
    },
    {
        "content": " 配置（Configuration） $ heroku create --buildpack https://github.com/heroku/heroku-buildpack-nodejs.git $ heroku buildpacks:add https://github.com/heroku/heroku-buildpack-python.git $ heroku addons:create heroku-postgresql:hobby-dev $ heroku addons:create heroku-redis:hobby-dev $ heroku addons:create sendgrid:starter $ heroku config:set ALLOWED_HOSTS=&#39;&lt;your hosts here&gt;&#39; $ heroku config:set NODE_MODULES_CACHE=false $ heroku config:set NPM_CONFIG_PRODUCTION=false $ heroku config:set SECRET_KEY=&#39;&lt;your secret key here&gt;&#39; Note\nHeroku 的存储是不稳定的。这意味着应用程序的所有实例都将具有单独的磁盘，并且每次重新启动应用程序时都将丢失对本地磁盘所做的所有更改。最好的方法是使用 Amazon S3 等云存储。有关配置详细信息，请参阅 Storing Files on Amazon S3 。\n部署（Deployment） $ git push heroku master 准备数据库（Preparing the Database） $ heroku run python manage.py migrate 更新货币汇率（Updating Currency Exchange Rates） 这需要定期运行。实现此目的的最佳方法是使用 Heroku 的调度程序服务（Heroku’s Scheduler service）。我们将其添加到我们的应用程序中：\n$ heroku addons:create scheduler 然后登录到您的 Heroku 帐户，在活动插件列表中找到 Heroku Scheduler 插件，并让它每天运行以下命令：\npython manage.py update_exchange_rates --all 启用 Elasticsearch（Enabling Elasticsearch） 默认情况下，Saleor 使用Postgres 作为搜索后端，但如果您想切换到 Elasticsearch，可以使用 Bonsai 插件轻松实现。为此，请运行以下命令：\n$ heroku addons:create bonsai:sandbox-6 --version=5.4 $ heroku run python manage.py search_index --create",
        "date": 1524096000,
        "objectID": "096c978898339716a9becb5f4b7bc5fe",
        "relpermalink": "/saleor/deployment/38_heroku/",
        "section": "saleor",
        "title": "Saleor 38: 部署 - Heroku",
        "size": 2652
    },
    {
        "content": " 如果您使用容器进行部署（包括 Docker 和 Heroku），您将希望避免将文件存储在容器的易失性文件系统中。此集成允许您将存储此类文件的任务委托给 Amazon’s S3 service。\n基本配置  AWS_ACCESS_KEY_ID  您的AWS访问密钥。\n AWS_SECRET_ACCESS_KEY  您的AWS秘密访问密钥。\n使用 S3 存储桶提供媒体文件 如果要存储和提供媒体文件，请设置以下环境变量以将 S3 用作媒体存储区：\n AWS_MEDIA_BUCKET_NAME  用于媒体文件的S3存储桶名称。\n如果您打算为媒体S3存储桶使用自定义域，则可以将此环境变量设置为您的自定义 S3 媒体域：\n AWS_MEDIA_CUSTOM_DOMAIN  用于媒体存储区的 S3 自定义域。\nNote\n媒体文件是指通过管理后台上传的每个数据（产品图像，类别图像等）\n使用 S3 存储桶提供静态文件 默认情况下，应用程序服务器将提供静态文件（例如显示页面所需的 CSS 和 JS 文件）。\n如果你打算为你的静态文件使用 S3，请设置一个额外的环境变量：\n AWS_STORAGE_BUCKET_NAME  用于静态文件的 S3 存储桶名称。\n如果您打算为静态 S3 存储桶使用自定义域，则可以将此环境变量设置为您的自定义 S3 域：\n AWS_STATIC_CUSTOM_DOMAIN  用于静态存储区的 S3 自定义域。\n",
        "date": 1524096000,
        "objectID": "851a5867ca8494c68a995bb184b6b39a",
        "relpermalink": "/saleor/deployment/39_s3/",
        "section": "saleor",
        "title": "Saleor 39: 部署 - 在 Amazon S3 上存储文件",
        "size": 1312
    },
    {
        "content": " 准备工作 在正式运行 Saleor 之前，需要在电脑上安装一些额外软件。\nNode.js 建议是 Version 8 或更高版本。\nNode.js downloads page\nPostgreSQL 运行 Saleor 需要 PostgreSQL version 9.4 或更高版本。\nPostgreSQL download page\n你一定要记住在安装的时候所设定的管理员密码。\nCommand Line Tools for Xcode 下载并安装最新版本的 &ldquo;Command Line Tools (macOS 10.x) for Xcode 9.x&rdquo;.\nDownloads for Apple Developers page\n然后运行：\n$ xcode-select --install Homebrew 运行下面的命令安装 Homebrew:\n$ /usr/bin/ruby -e &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&#34; Python 3 使用 Homebrew 安装最新版本的 Python 3:\n$ brew install python3 Git 使用 Homebrew 安装 Git:\n$ brew install git Gtk+ 使用 Homebrew 安装 the graphical libraries necessary for PDF creation:\n$ brew install cairo pango gdk-pixbuf libffi 安装  克隆这个仓库 （或是使用你自己的副本）：\n$ git clone https://github.com/mirumee/saleor.git 进入目录：\n$ cd saleor/ 安装依赖库：\n在安装任何 Python 包之前，我们强烈推荐先创建一个虚拟环境。\ncreating a virtual environment\n$ pip install -r requirements.txt 设置一个环境变量 SECRET_KEY :\n我们有想过设一个默认值，但是我们最终决定不设默认值，因为怕有人直接用这个默认值上了生产环境，所以还是由你自己来设一个。\n$ export SECRET_KEY=&#39;&lt;mysecretkey&gt;&#39; Warning  秘钥（Secret key）应该是一个只有你们团队自己知道的独一无二的字符串，使用一个别人可能知道的 SECRET_KEY 会破坏 Django 的许多安全性保护，并可能导致特权升级和远程代码执行漏洞。\n参考：Django&rsquo;s documentation\n\n 创建一个 PostgreSQL 用户：\n除非你已经设置过，否则商店的用户名和密码都默认是 saleor ，请记得给你的用户设置 SUPERUSER 权限，这样它才可以创建数据库和数据库扩展。\n$ createuser --superuser --pwprompt saleor 当提示需要密码的时候输入 saleor\n 准备数据库:\n$ python manage.py migrate Warning  这个命令需要有创建数据库扩展的权限，如果你收到与 CREATE EXTENSION 相关的错误信息请参考用户创建步骤的说明。\n\n 安装前端依赖库:\n$ npm install Note  如果这一步安装失败请回到上面去确认下使用的 Node.js 版本是不是足够新。\n\n 准备前端资源文件:\n$ npm run build-assets 编译电子邮件:\n$ npm run build-emails 启动开发服务器:\n$ python manage.py runserver  ",
        "date": 1524096000,
        "objectID": "a111eb67b03e6b3b3fe4f1a0563f4582",
        "relpermalink": "/saleor/getting-started/01_installation-macos/",
        "section": "saleor",
        "title": "Saleor 01: 入门 - 在 macOS 上安装",
        "size": 3352
    },
    {
        "content": " 我们在 64-bit Windows 系统上进行安装\n准备工作 在正式运行 Saleor 之前，需要在电脑上安装一些额外软件。\nPython 下载最新的 3.6 版 Windows 安装包，然后根据说明进行安装。\nPython download page\n记得勾选 &ldquo;Add Python 3.6 to PATH&ldquo;\nNode.js 建议是 Version 8 或更高版本。\nNode.js downloads page\n记得勾选 &ldquo;Add to PATH&ldquo;\nPostgreSQL 运行 Saleor 需要 PostgreSQL version 9.4 或更高版本。\nPostgreSQL download page\n你一定要记住在安装的时候所设定的管理员密码。\nGTK+ 下载 64-bit Windows installer\n记得勾选 &ldquo;Set up PATH environment variable to include GTK+&ldquo;\nCompilers 下载并安装最新版本的 Visual C++ build tools.\n安装  克隆这个仓库 （或是使用你自己的副本）：\n$ git clone https://github.com/mirumee/saleor.git 进入目录：\n$ cd saleor/ 安装依赖库：\n在安装任何 Python 包之前，我们强烈推荐先创建一个虚拟环境。\ncreating a virtual environment\n$ pip install -r requirements.txt 设置一个环境变量 SECRET_KEY :\n我们有想过设一个默认值，但是我们最终决定不设默认值，因为怕有人直接用这个默认值上了生产环境，所以还是由你自己来设一个。\n$ export SECRET_KEY=&#39;&lt;mysecretkey&gt;&#39; Warning  秘钥（Secret key）应该是一个只有你们团队自己知道的独一无二的字符串，使用一个别人可能知道的 SECRET_KEY 会破坏 Django 的许多安全性保护，并可能导致特权升级和远程代码执行漏洞。\n参考：Django&rsquo;s documentation\n\n 创建一个 PostgreSQL 用户：\n使用 pgAdmin 工具来为你的商店创建数据库用户\n除非你已经设置过，否则商店的用户名和密码都默认是 saleor ，请记得给你的用户设置 SUPERUSER 权限，这样它才可以创建数据库和数据库扩展。\n$ createuser --superuser --pwprompt saleor 当提示需要密码的时候输入 saleor\n 准备数据库:\n$ python manage.py migrate Warning  这个命令需要有创建数据库和数据库扩展的权限，如果你收到了相关的错误，请确认你是否分配了 SUPERUSER 权限。\n\n 安装前端依赖库:\n$ npm install Note  如果这一步安装失败请回到上面去确认下使用的 Node.js 版本是不是足够新。\n\n 准备前端资源文件:\n$ npm run build-assets 编译电子邮件:\n$ npm run build-emails 启动开发服务器:\n  $ python manage.py runserver",
        "date": 1524096000,
        "objectID": "276fed2c5a7d61620300036917a4ca38",
        "relpermalink": "/saleor/getting-started/02_installation-windows/",
        "section": "saleor",
        "title": "Saleor 02: 入门 - 在 Windows 上安装",
        "size": 2960
    },
    {
        "content": " 如果你偏向于使用容器服务或者是对配置 PostgreSQL, Redis and Elasticsearch 存在问题，可以尝试 Using Docker for Development 相关教程。\n准备工作 在正式运行 Saleor 之前，需要在电脑上安装一些额外软件。\nPython 3 Saleor 建议使用 Python 3.4 或者更高版本。大多数 Linux 系统都有一个内置已经安装好的版本，但是如果不是，那就要去了解下如何安装 Python 3.6.\nNode.js 建议是 Version 8 或更高版本。\n查看 installation instructions.\nNote  Debian 和 Ubuntu 用户使用系统安装包进行安装 Node.js 的话依然还需要安装 nodejs-legacy\n\nPostgreSQL 运行 Saleor 需要 PostgreSQL version 9.4 或更高版本。\nPostgreSQL download page\n你一定要记住在安装的时候所设定的管理员密码。\nGTK+ 有一些功能，比如“创建 PDF”，需要额外的系统库支持。\nDebian / Ubuntu Debian 9.0 Stretch 或以上, Ubuntu 16.04 Xenial 或以上:\n$ sudo apt-get install build-essential python3-dev python3-pip python3-cffi libcairo2 libpango-1.0-0 libpangocairo-1.0-0 libgdk-pixbuf2.0-0 libffi-dev shared-mime-info Fedora $ sudo yum install redhat-rpm-config python-devel python-pip python-cffi libffi-devel cairo pango gdk-pixbuf2 Archlinux $ sudo pacman -S python-pip cairo pango gdk-pixbuf2 libffi pkg-config Gentoo $ emerge pip cairo pango gdk-pixbuf cffi 安装  克隆这个仓库 （或是使用你自己的副本）：\n$ git clone https://github.com/mirumee/saleor.git 进入目录：\n$ cd saleor/ 安装依赖库：\n在安装任何 Python 包之前，我们强烈推荐先创建一个虚拟环境。\ncreating a virtual environment\n$ pip install -r requirements.txt 设置一个环境变量 SECRET_KEY :\n我们有想过设一个默认值，但是我们最终决定不设默认值，因为怕有人直接用这个默认值上了生产环境，所以还是由你自己来设一个。\n$ export SECRET_KEY=&#39;&lt;mysecretkey&gt;&#39; Warning  秘钥（Secret key）应该是一个只有你们团队自己知道的独一无二的字符串，使用一个别人可能知道的 SECRET_KEY 会破坏 Django 的许多安全性保护，并可能导致特权升级和远程代码执行漏洞。\n参考：Django&rsquo;s documentation\n\n 创建一个 PostgreSQL 用户：\n查看详情 PostgreSQL&rsquo;s createuser command\nNote  你需要为你的项目创建一个用户， 用户名和密码可以在 DATABASE_URL 这个环境变量中找到。如果没有设置过的话那默认就都是 saleor\n\nWarning  当创建数据库时，Django 需要创建一些 PostgreSQL 扩展，如果数据库里面没有的话，这个操作需要管理员权限。\n对于本地开发，你可以给你的数据库使用管理员权限。但是如果是在外部正式环境的话，建议专门设立一个管理员用户去做数据库操作。\n\n 准备数据库:\n$ python manage.py migrate Warning  这个命令需要有创建数据库和数据库扩展的权限，如果你收到了与 CREATE EXTENSION 相关的错误，请确认你在创建用户的时候是否分配了 SUPERUSER 权限。\n\n 安装前端依赖库:\n$ npm install Note  如果这一步安装失败请回到上面去确认下使用的 Node.js 版本是不是足够新。\n\n 准备前端资源文件:\n$ npm run build-assets 编译电子邮件:\n$ npm run build-emails 启动开发服务器:\n  $ python manage.py runserver",
        "date": 1524096000,
        "objectID": "add610649062ac82a514001257a98075",
        "relpermalink": "/saleor/getting-started/03_installation-linux/",
        "section": "saleor",
        "title": "Saleor 03: 入门 - 在 Linux 上安装",
        "size": 4140
    },
    {
        "content": " 我们是 12factor 方法和可移植代码的粉丝， 所以你仅仅使用环境变量就可以设置 Saleor 的大多数配置项。\n环境变量  ALLOWED_HOSTS\n控制 Django&rsquo;s allowed hosts 设置，默认是 localhost。使用英文逗号分隔多个值。\n CACHE_URL or REDIS_URL\n缓存数据库地址，默认是系统内存。我们推荐使用 Redis，Heroku 的 Redis 会自动导出这个配置。\n  Example: redis://redis.example.com:6379/0\nWarning\n\n如果你计划使用不止一个 WSGI 进程（或运行多个服务器/容器），则需要使用共享缓存服务器。否则，每个进程将拥有自己的每个用户会话的版本，这将导致用户被注销并丢失购物车。\n\n DATABASE_URL\n默认是本地 PostgreSQL 实例。查看 Using Docker for Development 了解如何在 Docker container 里面运行本地数据库。  大多数 Heroku 的数据库都会自动导出这个设置。\nExample: postgres://user:password@psql.example.com/database\n DEBUG\n控制 Django&rsquo;s debug mode 默认是 True\n DEFAULT_FROM_EMAIL\n电子邮件的默认发件人\n EMAIL_URL\n电子邮件网关地址。默认是打印输出所有信息到终端。\n  Example: smtp://user:password@smtp.example.com:465/?ssl=True\n INTERNAL_IPS\n控制 Django&rsquo;s internal IPs 设置。默认是 127.0.0.1  多个值用英文逗号分隔。\n SECRET_KEY\n控制 Django&rsquo;s secret key 设置。\n MAX_CART_LINE_QUANTITY\n控制可加入购物车单个产品的最大数量（这里我暂时也不太确定是指“单个购物车可添加产品的总数量/行数，还是指”单个产品的最大可购买数量“，原文：Controls maximum number of items in one cart line.）默认值是 50\n STATIC_URL\n控制资源文件的加载路径。默认是 /static/assets/\n  ",
        "date": 1524096000,
        "objectID": "899b09565a61af2edeb43607e8625ed1",
        "relpermalink": "/saleor/getting-started/04_configuration/",
        "section": "saleor",
        "title": "Saleor 04: 入门 - 设置",
        "size": 2160
    },
    {
        "content": "Saleor 是基于 Django 开发的，所以你可以使用下面的命令来创建管理员账户\n$ python manage.py createsuperuser 按照提示提供您的电子邮件地址和密码。\n然后你就可以启动本地服务并访问 http://localhost:8000/dashboard/ 登录到后台管理界面。\n请注意，以这种方式创建用户会使其成为“超级用户”状态，这意味着无论分配给哪个组，它们都具有所有权限。\n",
        "date": 1524096000,
        "objectID": "a31f22e812cb53657ba14e3366e951fc",
        "relpermalink": "/saleor/getting-started/05_superuser/",
        "section": "saleor",
        "title": "Saleor 05: 入门 - 创建一个管理员账户",
        "size": 490
    },
    {
        "content": " 我们内建了一些调试工具。\nDjango debug toolbar 如果 Django 是运行在 debug 模式下，Django Debug Toolbar 就是开启的。\nSilk Silk 开启与否可以通过环境变量来控制\n ENABLE_SILK\n控制 django-silk. 默认是 False   设置环境变量  $ export ENABLE_SILK=&#39;True&#39;  从 requirements_dev.txt 安装库:  $ python -m pip install -r requirements_dev.txt  重启服务  ",
        "date": 1524096000,
        "objectID": "2497802aad65d43ec353c49384e28bb0",
        "relpermalink": "/saleor/getting-started/06_dev-tools-2/",
        "section": "saleor",
        "title": "Saleor 06: 入门 - 调试工具",
        "size": 642
    },
    {
        "content": "如果您想要一些数据来测试您的新店面，您可以使用示例产品和订单填充数据库：\n$ python manage.py populatedb",
        "date": 1524096000,
        "objectID": "ed238fd8a26606ffcbecdc4975976837",
        "relpermalink": "/saleor/getting-started/07_example-data/",
        "section": "saleor",
        "title": "Saleor 07: 入门 - 测试数据",
        "size": 206
    },
    {
        "content": " Saleor 提供了通过管理后台处理订单的功能。订单可以在管理后台的 Orders 选项卡中处理完成。\n草稿订单 （Draft orders） 要创建草稿订单，首先您必须转到管理后台的 Orders 选项卡，然后选择现有订单列表上方可见的圆形 + 按钮。\n这些订单可以完全编辑，直到通过点击创建订单确认。您可以修改订购商品、客户（也只是设置电子邮件）、账单和送货地址、送货方式及折扣。您应用的任何凭证都会导致自动订单重新计算，以适应每次订单实际状态的变化。\n通过点击创建订单确认订单会将状态更改为未实现并禁用大部分编辑操作。您可以选择通过发送电子邮件通知客户 - 如果附加了任何 - 关于该订单。\n将订单标记为已付款（Marking orders as paid） 在订单详情页面，如果需要，您可以手动将订单标记为已付款。此选项仅在未付款订单中可见，作为付款卡中的操作。\nWarning\n您将无法退还手动处理的付款。这是由于缺乏足够的数据来处理事务。\n",
        "date": 1524096000,
        "objectID": "498cf53ef45e31be0d3b018e6d1ab754",
        "relpermalink": "/saleor/guides/40_orders/",
        "section": "saleor",
        "title": "Saleor 40: 操作指南 - 订单",
        "size": 928
    },
    {
        "content": " Saleor 提供了配置店面导航的功能。你可以在管理后台的 Navigation 选项卡中进行操作。\n您可以在每个创建的菜单中添加最多 3 层菜单项。每个菜单项都可以通过传递额外的 URL 来指向包含 Category，Collection，Page 或外部网站的内部页面。\n管理菜单项（Managing menu items） 要管理菜单项，首先您必须转到仪表板 Navigation 选项卡并选择要编辑的菜单。如果要管理嵌套的菜单项，可以上下浏览列出的菜单项。\n要添加新菜单项，请选择 Add 菜单项列表上方可见的按钮。然后填写表格并点击 Create。\n要编辑菜单项，请选择 Edit 列表上菜单项旁边可见的按钮或菜单项详细信息下方的按钮（如果您在菜单项详细信息视图内）。进行任何更改并单击。Edit menu item Update\n要删除菜单项，请选择 Remove 列表上菜单项旁边可见的按钮或菜单项详细信息下方的按钮（如果您在菜单项详细信息视图内）。此操作将删除所有后代项目，并且不能撤消。Remove menu item\n菜单项按菜单项列表中列出的顺序显示在店面上。您可以通过处理菜单项左侧的图标并将其拖动到另一个位置来重新排列它们。\n管理菜单（Managing menus） 管理后台为您提供添加新菜单的功能。\n一次可以有两个活动菜单（一个用于导航栏，另一个用于页脚，它们可以相同）。\n当前分配的菜单可以通过仪表板的 Navigation 面板进行更改。\n菜单默认呈现为垂直列表。你可以通过传递一个额外的 horizontal=True 参数来改变它。带有嵌套项目的水平菜单在桌面上显示为下拉菜单。\n",
        "date": 1524096000,
        "objectID": "9a202a0dc7c3232a4057c70a3811d769",
        "relpermalink": "/saleor/guides/41_navigation/",
        "section": "saleor",
        "title": "Saleor 41: 操作指南 - 导航",
        "size": 1494
    },
    {
        "content": " 在某些方面，Saleor 会自动处理搜索引擎如何查看和索引您的产品，开箱即用。\n站点地图（Sitemaps） 在 /sitemap.xml URL 下，这个可访问的特殊资源以所有主要搜索引擎最易于解析的 Sitemaps XML 格式提供您网站上的产品、类别和集合的最新列表。\n元标记（Meta Tags） Meta 关键字并未被使用，因为它被引入后的这几年被滥用，因为它们被所有主要搜索引擎忽略。\n元描述将被设置为产品的描述字段。这不会影响搜索引擎的排名，但会影响显示的搜索结果中的文本片段。\n机器人元标记（Robots Meta Tag） （这里机器人一般指搜索引擎的自动化爬虫。）\n机器人 meta 标签利用特定于页面的方式来控制如何将单个页面编入索引并提供给搜索结果中的用户。\n我们限制了信息中心管理面板的抓取和索引，无内容页面（例如购物车，注册，登录）不会被抓取。\n结构化数据（Structured Data） 主页和产品页面包含 JSON-LD 结构化数据 格式的语义描述。\n它不直接影响搜索引擎排名，但它允许搜索引擎更好地理解数据（“这是一款产品，它是可用的，它的价格为10美元）”。\n它允许像谷歌这样的搜索引擎显示产品照片，价格，可用性，评级等，以及他们的搜索结果。\nNofollow 链接（Nofollow links） 搜索引擎抓取工具无法在您的网站上登录或注册成为会员，也没有理由邀请他们按照“在此注册”或“登录”链接进行操作，因为这些链接几乎没有任何有价值的内容。\n这将优化抓取工具在网站上花费的时间，从而让它有时间去索引更多与内容相关的页面。\n",
        "date": 1524096000,
        "objectID": "c2fda75a3e9ad04052416eec461c500e",
        "relpermalink": "/saleor/integrations/30_seo/",
        "section": "saleor",
        "title": "Saleor 30: 集成 - 搜索引擎优化（SEO）",
        "size": 1446
    },
    {
        "content": " 打开图表 为了更有效和高效参与社交媒体，我们在主页和所有的产品/类别中添加了 Open Graph Protocol 。\nOpen Graph meta 标签可以控制在社交媒体上分享页面时显示的内容（描述，标题，网址，照片等），从而将您的网页转变为社交图表中的丰富对象。\n",
        "date": 1524096000,
        "objectID": "4ee8b17da1dadb75cb37c2d75752f573",
        "relpermalink": "/saleor/integrations/31_smo/",
        "section": "saleor",
        "title": "Saleor 31: 集成 - 社交媒体优化（SMO）",
        "size": 348
    },
    {
        "content": "Saleor 使用 schema.org 标记来突出显示电子邮件中最重要的信息，并允许用户轻松地与其进行交互。 订单确认电子邮件 将显示为交互式摘要卡片。\n电子邮件标记是默认启用的，但在您 向Google注册 之前，您的客户不会看到它。\n",
        "date": 1524096000,
        "objectID": "b8507a268700234048d87aa61ac7fcc2",
        "relpermalink": "/saleor/integrations/32_emailmarkup/",
        "section": "saleor",
        "title": "Saleor 32: 集成 - 电子邮件标记",
        "size": 312
    },
    {
        "content": " 安装 Elasticsearch 搜索后端需要 Elasticsearch 服务器。为了开发目的，docker-compose 将创建一个运行Elasticsearch 服务器实例的 Docker 容器。\n可以使用一组环境变量来配置集成。当您在 Heroku 上部署时，您可以使用提供 Elasticsearch 作为服务的附加组件。默认情况下，Saleor 使用Elasticsearch 5.4.3。\n如果您正在其他地方部署，则可以使用以下服务之一：\n  http://www.searchly.com/ https://www.elastic.co/cloud   环境变量  ELASTICSEARCH_URL或 BONSAI_URL 或 SEARCHBOX_URL  elasticsearch 引擎的网址。如果它是空的 - 搜索将不可用。例： https://user:password@my-3rdparty-es.com:9200\n数据索引 Saleor 使用的Django Elasticsearch DSL 作为用于包装 Elasticsearch DSL 启用自动索引和同步。索引在文档文件中定义。请参考上述项目的文件以获得进一步的帮助。\n初始搜索索引可以使用以下命令创建：\n$ python manage.py search_index --rebuild 默认情况下，每次更改索引对象（产品，用户，订单）都会重新编制索引。\n搜索集成架构 搜索后端使用 Elasticsearch DSL 在saleor / search / backends中查询定义。\n为 elasticsearch 集成，店面和管理后台定义了两个后端。店面搜索仅使用店面索引进行产品搜索，管理后台后端也在用户和订单索引中执行其他搜索。\n测试 搜索功能有两个级别的测试。Elasticsearch 查询的语法由后端的单元测试来保证，集成测试使用 VCR.py 来模拟外部通信。如果搜索逻辑被修改，请确保记录新的通信并相应地调整测试流程！Pytest将在 CI 的永久记录模式下运行 VCR 以确保没有尝试进行通信，因此请确保最新的卡带始终包含在您的存储库中。\n",
        "date": 1524096000,
        "objectID": "e7e372d9af1a6ea9c683de8651d4556c",
        "relpermalink": "/saleor/integrations/33_elasticsearch/",
        "section": "saleor",
        "title": "Saleor 33: 集成 - Elasticsearch 搜索",
        "size": 1932
    },
    {
        "content": "由于欧盟法律规定，Saleor 不会默认使用任何追踪 cookie。\n不过，我们使用 Google Analytics Measurement Protocol 支持服务器端 Google Analytics 。\n这是使用 google-measurement-protocol ，不使用 cookie，但代价是不会报告无法追踪服务器端的东西，如地理定位和屏幕分辨率。\n为了让它工作，你需要导出下面的环境变量：\n GOOGLE_ANALYTICS_TRACKING_ID  您的信息页的Google “跟踪 ID”。\n ​ ​  ",
        "date": 1524096000,
        "objectID": "60f001a4ee0ed0dddfc93e189e5978b6",
        "relpermalink": "/saleor/integrations/34_googleanalytics/",
        "section": "saleor",
        "title": "Saleor 34: 集成 - 谷歌分析",
        "size": 604
    },
    {
        "content": "Saleor 有用于生成产品 Feed 的工具，可用于 Google Merchant Center。最终文件被压缩成 CSV 并保存在 saleor.data_feeds.google_merchant.FILE_PATH 变量所指定的位置。\n要生成 Feed 使用命令：\n$ python manage.py update_feeds 建议定期运行此命令。\nMerchant Center 很少有国家/地区相关设置，因此请在 Google 信息中心验证您的 Feed。您还可以在那里指定您的运费，这是许多国家/地区必需的 Feed 参数。在 Google Support pages 可以找到更多信息。\nGoogle 所需的其中一项字段是*品牌*属性。Feed 生成器会在变体属性中对*品牌*或*发布商*进行检查（如果没有，则会去*产品*里面找）。\nFeed 可以从这个网址下载：http://&lt;yourserver&gt;/feeds/google/\n",
        "date": 1524096000,
        "objectID": "a277554b4f9ce47d844003a1ccbd62a1",
        "relpermalink": "/saleor/integrations/35_googleforretail/",
        "section": "saleor",
        "title": "Saleor 35: 集成 - 谷歌零售",
        "size": 938
    },
    {
        "content": "这种整合将使您的客户能够以当地货币查看产品价格。当地价格仅作为估算提供，客户仍按商店的默认货币收费。\n在开始之前，您需要一个 Open Exchange Rates account。除非您需要每天多次更新汇率，否则免费订阅计划应该足够了，当然也可以考虑为 Open Exchange Rates 提供的优质服务购买付费方案。首先去注册并创建一个“App ID”。\n导出以下环境变量：\n OPENEXCHANGERATES_API_KEY  您商店的开放式汇率“应用程序ID”。\n要更新汇率，至少每天运行一次以下命令：\n$ python manage.py update_exchange_rates --all Note\nHeroku 用户可以使用 Scheduler add-on 在预定义的时间每天自动调用该命令。\n",
        "date": 1524096000,
        "objectID": "d3f8c741f390a7b96aa4acd48793fdfa",
        "relpermalink": "/saleor/integrations/36_openexchangerates/",
        "section": "saleor",
        "title": "Saleor 36: 集成 - 汇率转换",
        "size": 794
    },
    {
        "content": "最开始，我这使用的是 Jekyll 来处理 Markdown 文件生成网站文件。\n前些时候，我筹备给它换到使用 Hugo 来处理。其中的一个主要原因，是因为：\n 我想每个类别存一个文件夹，比如可以单独归类的：Python、……；不能归类的：其它杂碎的文章…… 如果需要修改某一个目录的名称，或是重新为某一批文章进行归类整理，我不想要去每一个 .md 文件里去逐个修改，虽然存在可能我写个 .py 脚本来处理这个事情，但是始终不是个很好的操作。  出于我在想把一些可独立成文件夹的东西搬进来存着，比如一些工具的文档什么的，所以这个独立文件夹存储的确实很明确，所以就着手进行了。\n然后，结果有些东西就被我搞砸了，却没能有立即的完善解决方案和工具可用。\n不过现在终于弄好了，其实比想象中的更加容易些，没那么复杂了，总体上有这么几点拿出来说道说道的。\n首先我们使用反向推导的逻辑来思考如果需要修复搜索服务需要哪些东西：\n Algolia 的 API 是最终我们可操作更新索引内容的工具，有 Python 版的官方包，直接可接入基础的几个 API 操作，测试完成 在利用它 API 更新数据之前我们需要有数据，这个数据是什么，它其实是一个 json 文件，一个包含了多个文章字段索引内容的 list 那么就是如何得到这个 json 文件的事情了，自己写个工具来生成？这也是我曾考虑过的，然而其实后来发现有更好的方案，Hugo 支持多种模版输出，而其中便包含了可以输出 json 的方式，只要定义一个模版页面即可，而这个模版页面，自己贸然写可能有点难度，但是如果搜一搜，其实有人家写好的可以借鉴使用 那就是测试利用这个 json 模版输出 json 内容的问题了  所以接下来测试了几番，为什么是几番，因为有些需求需要自己处理下，比如：\n 有些不需要索引的页面需要去除 为了方便查看本次更新要对 json 文件进行二次处理，排序等等 字段命名是否合理，要改的就改  这些小问题都是 Python 直接操作会很方便，所以写个脚本来操作，加入 sh 文件里面使得在构建的时候就顺便自动也帮忙处理下 json 文件，确认没啥问题再更新 Algolia 索引数据，完美完成。\n当然在逐个步骤尝试的过程中还有遇到一些其它的问题，比如到底应该调用 addObjects add_objects 还是 update_objects save_objects 等等这些细节，不过这个去翻翻 Algolia 的文档就能明确的到答案的啦。\n有兴趣就多试试这个站内搜索，反正我目前蛮喜欢的，同时这套工具也正式应用到了朋友的企业内容站。\n往后，可能就会多放点内容到这里，然后也可以多做几个带搜索的东西了。\n",
        "date": 1524009600,
        "objectID": "be089636392434089e65d1c360ef542a",
        "relpermalink": "/post/2018-04-18-%E5%B0%8F%E7%AB%99%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%B7%B2%E6%88%90%E5%8A%9F%E5%88%87%E6%8D%A2%E5%88%B0-hugo/",
        "section": "post",
        "title": "小站构建工具已成功切换到 Hugo",
        "size": 2344
    },
    {
        "content": "上一篇简单提到，我上线了本站的站内搜索服务：Algolia，本来还写了有一些些的，然而，由于我所使用的 Markdown 编辑器 Typora 的问题，在我主动按下 Command + S 的时候有较高概率会触发崩溃（按照默认的设定直接关闭文件就是自动保存，可是人总是想更保险一点是吧，可结果……），所以，当时崩溃又写了些，写了些又崩溃，然后又写了些，又崩溃，又只要仓促写了些，毕竟大半夜的还是要睡觉的。\nTypora 最近又更新了好几次，刚还遇到不能回删文字的情况，可能还是系统兼容问题吧，希望工程师们能有精力尽快完成修复了。\n今天，我有意识控制不去按 Command + S，其实在 macOS 的逻辑里，好多的软件都默认是自动保存的，不过还是有一些不是，这使得习惯还是会有些些分裂，要是厉害了，还是有可能导致精神分裂的。\n还是谈今天的主题：我是如何搞砸了本站的搜索服务的\n上线了搜索服务后，搜索体验在所有遇见过的站内搜索中，算是顶级水准了。\n从产品来看，这个搜索服务的所有操作体验应该是完全没得话说的，后台漂亮，数据清晰，API 工具所提供的接口也及其清晰明了好理解，文档更是做的非常好了，我这个英语渣整篇看下去完全没问题，偶尔几个不认识的单词，用下 macOS 系统自带的词典，选中单词就查得到中英解释。\n但是，要说这个产品在国内的被使用情况，真不咋样普遍，为啥呢。\n首先来说，它真的就是专门做搜索外包服务的，SaaS 模式，提供一个服务解决方案给你使用，直接靠这个产品本身来挣钱的，跟谷歌这类性质完全不一样。也就是说，它其实是个付费接入才能使用的服务。不过我这里不用担心，它同样有一个免费的方案 COMMUNITY Plan 提供给我们这样的普通小站用户，可存储一万条记录，每个月有十万次操作数可供增删改查使用，对于咱这样的小站来说，目前及未来可预见一段时间内，完全足够了。\n它还有个特别的服务：DocSearch，用来干嘛的呢，一般人看名字看不明白，程序员可能一眼就理解了：用来做“文档搜索”的，什么是文档，就是大多数时候被称作 Documentation 类似这样的东西，就是差不多是“说明书”的意思了，一个工具如何去正确使用，是怎样的设计理念，有哪些问题需要解决，未来如何发展等等。\nDocSearch，这个东西，免费提供的，最简单的使用方式：提交你的网站，通过了，它便帮你建立索引，然后会告诉你如何接入搜索功能，这样，就能有了搜索服务了。不过，我的理解应该不是所有网站都能被索引，应该仅限于互联网技术类文档吧，毕竟从列出的例子来看是这样的。\n个人博客这样的小站还是自己折腾下吧，自己的东西不拿来折腾，还要拿谁的来玩呢。\n本站是免费托管在 github.io 上，这是要让你知道的。自然地，上一版用来构建本站的工具就是使用的它官方所支持的 Jekyll 来处理 Markdown 文件来构建博客内容。\n使用了配套的由 Algolia 官方推荐的索引工具 Algolia for Jekyll，就这样，上一版就这样成功地实现了搜索服务。\n但是，为什么要有但是，就是因为其实在程序员的世界，永远不会满足于已有的工具，最开始用的好好的，但凡是发现了新的工具或者是原有工具遇到了根本性的痛点，转身离开的样子是绝不会回头半分的。\n是的，我发现了 Hugo，基于对 Go 语言有一些些道听途说的好感，也测试了 Hugo 的运行情况，认为完全有必要用它来替代目前的 Jekyll 来处理这个站的内容。\n就这样，我把构建工具切换到了 Hugo，重新研究了模版的设计，又原模原样地利用了已有的资源搭起来了这个小站。\n等搞定一切最终发布到线上之后，问题终于来了：搜索服务没一个点进去能看的，文章 URL 全部失效了。\n第一步：更新索引，有找到 hugo-algolia 与 atomic-algolia 这两个看似配套的工具，尝试用 hugo-algolia 去建立新的索引内容，清空原有索引 - 成功、添加新索引 - 失败，数据就这样没了。hugo-algolia 所报出来的错误我也完全无从查起，搁置。也没心思去研究 atomic-algolia 了，pass。\n第二步：恢复索引，切换到原有 Jekyll 分支，重建索引，报错，因为还是多了很多文件的，具体不细究。还好更新到 github.com 之前先下载了备份，用它重建索引，完成。\n中间还有一些其它的尝试操作，就不细叙了。\n所以，现在还是首页依然所有搜索结果的 URL 是点击不了的，而菜单页入口的文章列表也还有些问题。\n为啥页面看上去如此简单，因为不熟悉这个新东西的话，保持最简单的可运行实现，是建立一步步继续研究信心的关键，而页面设计恰恰并不是我所擅长，所以暂时就照原有最简单的实现吧，何况我也喜欢简约风格。\n现在写这篇文章之时，它的搜索服务依然是无法完整地正常使用的。\n接下来的打算：\n 无论是 Algolia for Jekyll 还是 hugo-algolia 与 atomic-algolia，逻辑上均应是利用 Algolia 的 API 工具操作数据，目前已测试 Python 版的 API 工具，基本情况都了解了。 无论是利用 Jekyll 或者 Hugo 别人写的工具来更新数据，均存在不合理的地方，特别是 hugo-algolia 可能仅仅是个半成品差不多，而我并不想去提 PR，毕竟非我所熟悉的语言领域，所以考虑的一个方案就是自己写个小小工具专门配套我的内容建立索引，毕竟 Python 开发起来并不难，前提是想清楚方法和细节。 说不难，也还是有写难度的，如果这小工具做好，感觉利用 Python 处理 Markdown 生成静态网站页面的内在知识也应该翻的差不多了，可能到时候又会有新方案？ 虽然还有个方案是修改 Hugo 的配置和模版来修复 URL 问题，但是我不想了，看上的就是 Hugo 的 Markdown 文件管理模式，要走就走的彻底些。 细节就不絮叨了，大概如上。  毕竟是自己的小站，访问量几乎可以忽略不计，功能简单随便玩，只要不全挂，我就还会整更好的。\n深入研究某个东西，是个及其耗时的操作，而勉强搭建起来可以跑，只是蜻蜓点水，对成长没有助力的。\n而心却慌慌。\n",
        "date": 1523577600,
        "objectID": "06c7923c40c8cb9a6bc738e8e3d07156",
        "relpermalink": "/post/2018-04-13-%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%90%9E%E7%A0%B8%E4%BA%86%E6%9C%AC%E7%AB%99%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E7%9A%84/",
        "section": "post",
        "title": "我是如何搞砸了本站搜索服务的",
        "size": 5234
    },
    {
        "content": "大约在一年前左右，瞅到 Vue.js 使用的站内搜索与别的网站有些不一样，不仅仅不一样，而且有些特别。如果是在 Windows 系统上面曾经有谁用过 Everything 这个软件或者类似替代品的话，能知道它的实时输入搜索是多好的体验，得知道曾经系统自带的搜索功能就是等于几乎没有。\n做搜索，绝不仅仅是看起来的那么简单，大到 Google 和 Bing 这种搜索巨头，小到记事本里面的查找搜索，大大小小各类搜索需求，搜索，是人的主动寻找行为，比起无意识的随便浏览，是高效很多的。\nAlgolia，据说是来自法国的初创公司，国内还没有看到有大面积的使用，虽然说搜索重要，可并不是谁都做的好，特别是站内搜索，多数的产品都是食之无味弃之可惜，但现今这款产品，醒目得很。\n至于具体的技术细节，我也没去洗洗研究，还不如直接上手多试几次搜索看看，看这体验如何。\n这次就不多说了，再会。\n其实是编辑器多次无故奔溃，丢失上一次保存之后的东西，我很无语啊。\n",
        "date": 1521417600,
        "objectID": "737c3845e0b6e839915bd7fe8573e74c",
        "relpermalink": "/post/2018-03-19-%E7%8E%B0%E5%B7%B2%E5%8A%A0%E5%85%A5-algolia-%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1/",
        "section": "post",
        "title": "现已加入 Algolia 搜索服务",
        "size": 914
    },
    {
        "content": "今年应该是冷死了，上周感冒，后来我反思原因，可能就是在办公室冻着了。\n现在完全不敢再说不怕冷了，可惜家里空调开了也并无大作用，昨天偶然机会在星巴克小坐一会儿，我突然觉得那才是我能正常待下去思考的温度。\n农历新年就快要到来了，之前做了个小小的物流数据产品：国际快递燃油附加费率。觉得还是需要拿出来溜溜，可之前一直没决心搞下那几张图片，今晚索性就搞上几张图片，现在这个网站整体上，总算是可以拿出去还算是能看的了。\n网站是给朋友做的，所以网站不是我的。我这里的这篇文章不作为他家公司的产品推介，我只是想说说其中一个完全由我想出来，然后花了一个周末两天时间给完整实现出来的这个产品，就是这个小小的「燃油附加费」。\n因为我在上家公司就是全权负责物流板块嘛，所以自认为对日常实操还算是有很细致了解的。在日常工作中，其中一个是计算当前物流费用，一般需要频繁拿到物流费用参考值的部门是客服与运营，采购与开发部门偶尔也需要，再可能就是领导问起或是会议汇报会需要计算，这其中会需要用到渠道报价与渠道当前燃油费率；另外一个更加重要的地方是，对账，一般来说，对账会按照帐期或者是定期进行，相对出货来说就存在一定延迟，所以这时候不仅仅需要的是当前渠道报价与当前燃油费率，而且还会需要历史数据，每一份数据都会有一个生效日期，也就是会在某一段时间内是需要某份数据，而另外一段时间则需要另外一份数据。\n在我曾经的工作中，我会维护一份我公司的全部渠道历史报价数据与燃油费率数据记录，以实现实时计算当前价格以及进行历史出货对账核算操作。渠道报价数据是每个公司不同，而国际燃油附加费率却是统一标准，大陆与香港地区甚至某些渠道将整个亚太地区作为一个片区设定相同的燃油费率。\n虽然燃油费率均可以在各个渠道的官方网站查看得到，但是他们均不保留全部历史数据的查看，比如 DHL 提供近 3 个月，UPS 提供最近 90 天，差不多可以认为也是 3 个月的意思，其它渠道类似。\n所以如果是有需要第一时间知道最新的各个渠道的数据，一个方式是查看各个渠道网站（更新时间有规律），另外一个方式是等候业务员通知（一般是晚个一两天），而如果是需要维护一个历史数据表，则需要有人有心记录并维护了。由于每个渠道的数据说明格式有些差异，则需要有人能理解并处理好以便可以供规范化计算使用。\n有一些物流商也会维护燃油费率信息，但是我看一圈下来，他们 99.9999% 均都是每隔一段时间使用固定模版发布一篇简短的文章，然后复制粘贴各个渠道的费率信息。这？这不是我想要的使用数据的合理方式。\n基于我的想法，我通过利用程序自动获取各个渠道的更新，将各个渠道数据统一整理规范，得到一份既可以随时查看到最新数据，又可以看到历史数据，并且数据格式对 Excel 友好方便直接复制粘贴使用，对人也友好方便查看。\n排序模式是倒序，最新的在上面，如果是懂 Excel 的同学则可以知道利用 Index + Match 函数就可以自动得出曾经某一天的燃油费率。\n历史数据我已经尽力找到了往前一些日子的，往后的就是程序自动更新了。\n希望，一款小小的产品，对大家能有一些使用价值。\n这便是我做这款小小的产品时候的一些思考。\n如果有兴趣看看产品，请点击阅读原文去网站查看。\n",
        "date": 1517788800,
        "objectID": "961aa82320226a3f3346f15a20bd4456",
        "relpermalink": "/post/2018-02-05-%E4%B8%80%E6%AC%BE%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%89%A9%E6%B5%81%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81/",
        "section": "post",
        "title": "一款小小的物流数据产品",
        "size": 2756
    },
    {
        "content": "新年伊始，咱们这又来了新朋友，欢迎你们！\n过去的一年我大概算了下，咱们这是：月更。平均一个月更新一次，有时候间隔长一些，有时候频繁点点。\n新的一年，没什么特别意外的话，我还会继续时不时地写一点点东西。在更新频率上，我对于现在我持续在看的那些号相比，他们的文字能力我只能是羡慕了，他们一年几十万字的产出，内容覆盖相关的多个方面，专业度与人文广度，非一般人可企及。\n这里并没有消极的意思，而准确说的意思应该是：以自己力所能及，逐渐精进。用胡适老爷子的话来说就是：怕什么真理无穷，进一寸有一寸的欢喜。羡慕是没有用的，放下心，去实践，深入细节，能往前走一步，便有一分收获，即便暂时做不到很好也无需忐忑，需相信往后总可以做到的。\n切回主题，由于「小道消息」公布了两个小程序的 AppID，这样我也有机会在咱们这关联上它们。\n第一个是 Readhub，整合了科技与互联网行业的一些资讯，在视觉与交互设计上都是很不错的资讯类小程序。以前我刚来到深圳进入工作岗位的时候，也会关注许多科技与互联网类信息网站，那时候也会去使用 RSS 订阅功能，不过后来 RSS 大势已去，这又是另外一个话题了。\n最近也曾看到有很多类似的公司抓取各大新闻网站内容，然后通过内容分析与聚合技术构建了一些类似的产品，但是最终并不会给源网站带去任何流量输送，也更不用说这种做法的合理性了。而 Readhub 则是导向源网站浏览，这样也就不会是那种拿了别人的鸡来生蛋却不给蛋也不还鸡了。这样如果有些内容优质的站点，也算是多了一个合理的分发渠道了，不过也要吐槽的是引导过去后个别网站的浏览体验真是还停留在十年前的样子。\n另外一款，名字叫「抽奖助手」，看名字就很直观地知道它是干嘛的啦。\n应该现在很多公司都在开年会，吃吃喝喝，玩玩抽奖，小道消息他们公司还真是会挑东西做。就不具体介绍了，我早几天帮忙给「土豆儿」买寄养券，京东支付给我优惠了 10 块钱，这刚好，我就拿来给咱们大家抽奖了吧，设 3 个红包，每个 3 块，嗯，我也还有 1 块。\n点击下面的小程序卡片参与抽奖即可，明儿中午它就自动开奖了，但是我还没弄明白开奖了之后我要怎么操作，那就明儿开了咱再继续研究。你问我「土豆儿」是谁？我只能告诉你说：土豆儿它是只狗。\n 注：小程序的入口请使用微信扫码订阅公众号打开本文\n ",
        "date": 1515628800,
        "objectID": "a111d1c4c9c6296abfca047ac1dec0a5",
        "relpermalink": "/post/2018-01-11-%E5%85%B3%E8%81%94%E4%BA%86%E4%B8%A4%E6%AC%BE%E5%B0%8F%E7%A8%8B%E5%BA%8F/",
        "section": "post",
        "title": "关联了两个小程序",
        "size": 2002
    },
    {
        "content": "如果按商业角度来讲，我是该把所有下列域名全部给注册了的：\njeremyyin.co jeremyyin.net jeremyyin.org jeremyyin.me jeremyyin.cc jeremyyin.vip jeremyyin.cn 甚至可能还有：\njeremyy.in ... 以及还可能有：\nxyin.com xyin.co //这个已经被注册了 ... jeremyx.com jeremyx.co ... xjeremy.com xjeremy.co ... 如果要是还有这个域名：\njeremy.yin 可惜并没有，不然我就更加要买下了。\n不过呢，又有啥必要呢，并不是不差钱的角儿，拿下个 jeremyyin.com 就差不多了，挂个能留下点文字的地方，够了。虽然不是什么足够短又足够好记的域名，不过却具有鲜明的个人主义色彩，这可以了。\n因为做了程序员的关系，自然没能免俗地去 https://pages.github.com 建立了一个仓库，这样，这些文字除了在微信公众号发布之外，也在 http://jeremyyin2012.github.io 留下了一个汇集之处。\n现在，如果再打开这个链接，它便会自动变成了 https://jeremyyin.com ，它们，现在更加个性化了。\n同时地，有了域名就可以设置自定义 DNS 解析，同时配合利用服务商的免费全球 CDN 加速，现在，加载速度更加快了，比 github.io 更快。\n我想，这样，如果未来有更多的东西放在上面，访问起来就更加舒服了。\n嗯，喜欢就好：jeremyyin.com 。\n",
        "date": 1513296000,
        "objectID": "68c0793ca05427f9ef0ff71aa84b75b2",
        "relpermalink": "/post/2017-12-15-%E4%B9%B0%E4%B8%AA%E5%9F%9F%E5%90%8Djeremyyin.com/",
        "section": "post",
        "title": "买个域名：jeremyyin.com",
        "size": 1446
    },
    {
        "content": "Dear Jeremy,\n展信佳。许久未能再与你回信，真是很不好意思。我现在正在 2017 年末，再过一个多月，离你正好就快 10 年了。我挺喜欢现在的这个时间的，现在大家也不用写信了，我只在这里的一个商场里面见到过，那是写给不具名的未来，也不知道地址的，可能最终，就飘向了某个无人的空间了吧。现在，我们都用智能手机了，对，就是 Jobs 那种的，用手指点来点去的那种，不过比那个高级多了，可以装很多程序了。当然，病毒也是可以装进去的。\n你问我走得快不快，我不知道，总是就这么走来了，前一次我跟你说我去那公司才真实地收获了一些 Money，然后又挥霍一空的事情吧，是啊，挥霍一空的感觉真是好喜欢又恐惧，后来真是好险啊。\n其实，很久未回你呢，也是最近情绪持续性地跌宕起伏啦，不像之前一些时候跟你说的那样风平浪静。是呢，处着呢。不必太过担心啦，起起伏伏正常的呢，不过确实想起你呢，真是好想你啊。2008 年应该是你写出最后一封信的时候吧，刚好，你也可以用得上手机了，不用再去买 200 卡和 IC 卡大晚上地去冷风飕飕的电话亭了。是呢，现在电话资费便宜的也很便宜了，漫游都取消了，现在都上 4G 网络和 Wi-Fi 了。对啊，那规定还是等于就是废了呢，技术潮流是挡不住的。不过呢，现在啊，我都几乎不打电话了，原因吧，呃，身边已没人再会如此了，时间那么久的，谁还有心思一起陪无聊啊。\n今天呢，我把那些信件翻了几个看了看。从你那里到我这里，它们静静地跟了我这么远，我很久不曾再打开过它们。我一直有个念头，我想着把它们都变成电子的，就像是现在，我给你发的电子稿这样。还记得我跟你说，写字不好就不好了吧，已经没有合适的机会让你练好字了，时机早就和你错过了，未来就是计算机键盘的天下，一样可以写字儿，不怕的。不过呢，我想着，它们现在存着的样子应该是最好的样子，也不必再去折腾它们了，从过去来的，留存着过去的气息，电子稿就确实没有这个味道。\n确实，从你那里走来，我这似乎还是第一次真正再仔细去瞧过它们。\n等你这个学期完了，你就准时回吧，那年天气不好呢，雪灾呢，那时候家里没受到太大影响，但是也好久一段时间没有电呢，我提前跟说下，别在外面逗留太久，千万记得。\n翻开你那年的收到的文字，真是温暖的很啊，可又不知道你那年发出的文字到底是什么样子的了，我只看到唯一一封你外封上写着“一封可能再也没有机会寄出的信”，这里面还留存了一些你的些许言语，看起来一副离别的样子。\n实在要跟你说对不起的，你写信的那些人，我一路走着，我都给弄丢了。你也别责问我怎么弄丢的，我自己也无法说的清楚，可能是时间导致的吧，是吧，它一直是那样谁都不管不顾的，一分一秒都不管就一直带我们走着。我这样把责任都推它身上，我是很赖皮了，可已然发生的事情，真是难以捉摸呢。如果跟你说下能改变点什么的话，我希望你在陪着时间向前走的时候，不要那么决绝吧，或许没有那么难受。\n是啊，经常难受。当船离开的时候，就更难受了。\n好了，很晚了呢，我明儿还得上班，只能先到这里了，再晚明儿就没法正常工作了。是啊，我这时间早已然不是那么随意的了，你仅且任性哈，记得照顾好自己。如果你想的话，与人一起相互多多照顾也是很好的嘛，你懂我意思啦，有些事还是早一些的好，性情正合适的年纪。\n2008 年真是个好年纪啊！\n2017.11.6 晚 多云\nyours Jeremy\n",
        "date": 1509926400,
        "objectID": "c7abaf3c2f06694b7eb3989229a70ccb",
        "relpermalink": "/post/2017-11-06-2008%E5%B9%B4%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%B9%B4%E7%BA%AA/",
        "section": "post",
        "title": "2008 年是个好年纪",
        "size": 2864
    },
    {
        "content": "在《绿光森林》中欧文在某个时刻对苏菲说：adajiu，被苏菲追问一通。而其源由于音乐专业术语：adagio，欧文搞音乐的嘛，自然。\n至于为什么还记得有这么一幕，我也不知道，反正这些年它时不时地就会冒出来一下，比如这次又冒出来了。\n当时无所事事，也没啥可玩弄的物件，也没啥可去的地方，以此度过不问世事的年纪，当也是很好的娱乐了。\n后来不知何时起，直接把连续剧类全部默认拉入了黑名单，除非特别有机缘，否则是不会去看的，所以这些年看过的剧也可能手指头能数得过来了，还好，电影可能数不完。\n当年在学校时一部《蜗居》惹的满世界的讨论，可今天再回看，编剧组的脑洞还是不够大啊，或者说，可能想象力的胆子也还不够大，谁又能想象数年之后，这满世界的如此荒芜呢。\n还是威廉帅。\n时间没有被拿去刷剧，那时间就总有地方用掉了，不然怎么从哪里多出那么多时间可以用来颓废。每次电影看完，还不忘记再去豆瓣瞧瞧别人怎么说，又或者是有和疑问与不解的地方，可终究能记住某些瞬间的，没有多少，感受都到骨子里了吧，或许是这样安慰着自己就是可以的。\n自打毕业来深圳已快近 6 年，回想起，可能有两段时间是忘记了日月星辰。一段可能是拿着伍昊的两本 Excel 书的时候，另外一段，我觉着应该是把物流跟踪信息自动更新以及建立起订单数据共享操作服务的那两个月，Python 此时算是入了门。\n回望下，往严重了讲，那可能是关系着后来自己生死存亡的两段时间。\n一些事情发生的时候，一环接着一环，谁也不知道未来会发生什么，但是呢，又貌似冥冥之中，这些话，可能之前也讲过了，一种体会而已。\n不过呢，Python 操作 Excel 也是顺手得很了：\n 使用 Python，我们有个软件包（库）叫 Pandas，很多人总叫它“熊猫”，而其实大多数时候用中文输入法直接输的时候输入法总是给我提示“潘大师”，或许，这个人确实很流弊吧，可我始终也不知道是谁。\n一行 df = pd.read_excel(&quot;filename.xlsx&quot;) 把数据读起来，再有各种数据操作几下，想干嘛干嘛，计算个几百万行也就零点几秒的事情，然后又是一行 df.to_excel(&quot;filename_output.xlsx&quot;) 就把数据输出到文件了，爽快的不得了，谁让看数据的话，还是 Excel 来的直接又暴力呢。\n最近使用它的透视表用的爽滑得很：\ndf_pivot = df.pivot_table(index=[...], aggfunc={...}) ，数据再多也不在话下吧。\n “列操作”的思维从 Excel 那里已深有体会，而到了 Pandas 这里，深刻得不能再深刻了，也不用说“数据类型一致性”的规范有多么重要了，现在看到谁在 Excel 单元格里面使用 - 作为零值占位符简直就想立马一棒子挥过去对吧。还好，Python 也能从容面对各种数据奇葩，难看的是脸。\n写 Python 最喜欢 Mac，可是 Excel 还是 Windows 流弊，不得不叹气，Parallels 这个不仁不义的，macOS 一升级发大版本它就跟着发新版本跟你说咱们又可以付款升级了亲，升级只要……\n可一年不到你就都已经发两个大版本了，真是懒得理你。\n去年有人推荐的《信号》，存都存了，最后依然没看，后来了我跑去看《虫师》了，实在说不出来是治愈系还是致郁系，可却是是一个人躲起来看很舒服的。\n对了，据说四川辣酱火了，果然还是火爆了，都是因为《Rick and Morty》，如果你连过我的热点 Wi-Fi ，你是否还记得曾问我这密码怎么辣么复杂，可其实一点也不复杂对吧。\n“人”这种生物才复杂。\n",
        "date": 1507766400,
        "objectID": "fbbfbe53febe1282209c6c512c69f5b4",
        "relpermalink": "/post/2017-10-12-%E6%85%A2%E5%8D%8A%E6%8B%8D/",
        "section": "post",
        "title": "慢半拍",
        "size": 3116
    },
    {
        "content": "按说我不酗酒不抽烟不赌博不嫖娼不沉迷游戏，实在不忍也就自己放飞机，尽量不带给别人负面情绪，不增加他人负担，明面儿上别人说理性沉稳、不急不躁，这确实应没啥太多说头了。\n可有一感觉挡不住：颓废感。\n时常想，那些手里夹着烟孤身行走抑或是依靠栏杆的人们，他们手里夹着的其实到底应该是什么？当吞吐之间，吸收与释放的又该是什么？\n又或是想，那些以酒期望灌醉自己深门闭户躲在黑暗角落偶然间盯着那一束亮光泪光闪烁时候，对旁人来说，他又是谁？\n我时常走在路上脚步飞快，不忍多停留，无论是嘈杂声音或者又是刺鼻气味都使得难以多留片刻。待到安静清新路段，才不自觉地慢下脚步，无论左看还是右盼，也不会记得擦肩而过的人是谁。\n插播下故事：\n今日坐公交回来，旁边座位两女自顾自讨论其中一人离婚事情。自我叙述：\n 我这次拖拉杆箱出来，小姑倒是有留我的意思，他肯定是不会来拦我的。我承认以前是我脾气不好丢过他几次行李箱和衣服说让他滚，可那是我真很生气。我们本来就没啥感情结的婚，还是闪婚。现在这么搞，他也肯定是不会在乎我的感受了。离就离吧，也让朋友他帮忙找好律师了，家产也还是要分点的。\n 不是我故意听人家家事，但是坐旁边不听到也不可能了。\n不是非得替这男的说话，可是想想，面对一次又一次行李箱和衣服被丢出门外，一次又一次歇斯底里地”滚“，而本身还没有什么感情和留恋的闪婚，如果还想着要照顾谁的感受，只可能要么钱在人家手里，或者命在人家手里了。\n下车想了想，又一个负面。\n城市给了我们很好的地方让自己有机会独处于世而又不惊扰世人，可能走在街上刚扔完烟头准备上楼的那个人，回家得面对家人的抱怨。可能那个躲在角落里喝酒的那个人，心里有些话想对谁说，可是又并不是适合对任何人说起，毕竟不是随便一个人就能承受起他所经历过的痛楚，即便不是直接经历，即便只是可能的一番描述。\n而我，或许有时候走在某个公园的小路上，或又是坐在某个椅子边，眼神呆滞，面无表情，多半，心在颓废期。\n只是现在公园少有去，蚊子多，反倒是家里空调舒适度高很多，动不动一走神就可能一晚上过去了。\n女朋友看不得我颓废的样子，甚至不愿听到我“今天好像没干些什么”的回答。\n面对这样的场景，我的颓废感猛然间又增多了很厚很厚的。\n或许，如若颓废感的行为之一不是葛优躺，而是换成打坐，可能听起来就完全不一样了吧。\n这生活，可是无力的很了呢。\n要么就再等几天可能就会好些了吧，总是如此往复无常。\n",
        "date": 1507680000,
        "objectID": "d8a9096c29b4857d7ff952be2ac7d1dc",
        "relpermalink": "/post/2017-10-11-%E9%A2%93%E5%BA%9F%E6%84%9F%E7%9A%84%E6%9D%A5%E6%BA%90/",
        "section": "post",
        "title": "颓废感的来源",
        "size": 2082
    },
    {
        "content": "这标题没写完，可能原应该是：错过再多，也不要错过自己。\n到底错过了什么，时年二十多岁，如果没有由头，恐怕贸贸然是讲不不起来的。\n近日前，曾有人给我留了这么一句：\n 不用刻意，我也不想再像以前一样去再意那些了，该慢慢沉淀自己，过自己想要的生活，睡，晚安\n 这样的言语在我如今的生活中来看，看得我云里雾里。\n但有种感觉是毋庸置疑的，当刻意在乎的东西不再那么在乎，当曾经的兴趣已经不再得以满足，当已然决定转身不管不顾身前身边事，当把自己包裹在一个狭小的空间中，的这些时刻，生活已然告一段落。\n告一段落，是决定以新的或者重新以一个心态去看待曾经发生过的事情，以及即将到来的未知的世界。\n这又让我想起《山河故人》，当在和平年代，生命长河没有战争威胁，不用担心生命危险，不必为下一晚在哪个路边停留而忧愁，然而，我们依然会面对人来人往，风云变幻的时间流逝。\n可知道，能陪走一段已然很荣幸至极，也就都值得了吧。\n为什么在此提起《山河故人》，是它点醒了一件事情，那便是没有人会永远地互相陪伴走到永久，伴侣会遇到各种原因而离开，父母也会因时间而离开，孩子也会因长大而离开，朋友会因各种因素悄然地就不见了踪影，又或许会在某个时刻蹦出在你眼前，可也未必有心理准备可以承受的起。\n或甚至，当知道真相的时刻，更深感往事如梦如烟如醉如痴，又如此多伤。\n也在不久前，《雄狮》上映，与某人去看了，为此我也在 iPad 上重新找到 Google Earth 来看，而同时又回想几年前凭着有限的记忆与状态处于云里雾里的朋友一起走上寻找印象的路程。\n路，还是那条路，人呢？\n让它深埋，让它过去，曾经存在过，又偶然出现了，一晃而过，往事不可追。\n",
        "date": 1504828800,
        "objectID": "cf174091ae7293a04b1e4faa0f3026d4",
        "relpermalink": "/post/2017-09-08-%E9%94%99%E8%BF%87%E5%86%8D%E5%A4%9A/",
        "section": "post",
        "title": "错过再多",
        "size": 1478
    },
    {
        "content": "15 年开始学习 Python 的时候，看遍了大家关于应该选择 Python 2 还是 Python 3 的讨论和争执，还有，妥协。\n按照我买电子产品“买新不买旧，买好不买差”的原则，我毅然决定先从了 Python 3 再说。\n是的，争执无意义，行动才是根本。\n后来，进了新公司，放眼望去是 Python 2 的世界，曾有想法切换，却始终被几个函数限制，没能彻底实现下来。\n昨日，开了个新项目，心思又动起来。\n今日，将原来的函数研究一番，可以连通了。\n以后的新项目，就走向 Python 3 吧。\n未来，是它的。\n&ndash;\n今年 Python 这门程序语言终于冲上了头牌，在机器学习、大数据分析、人工智能等几个领域热火朝天。\n然而，现实情况是无论外面如何热火，却没有当初那种决然冲进去弄一把再看的动力，说到底，还是没有实际的目标可以拿来玩耍。\n先做做 Web 也好吧，是时机未到。\n想想呢，我们确实处在一个最好的时代，Python 3 发展了好多年，相关的配套也都成熟，开箱可用，拿来就用，上手简单，做事容易，实在是最好的时代，连我这样贸贸然闯进来的也能无所畏惧地动手。\n不过这样被如此美好的时代所惯坏的开发者，很多时候，真是懒得动手，一想着有点复杂操作的就觉得痛苦，凡是步骤超过 5 步的操作都觉得烦操，最好是一行代码或者命令就能操作起一切。\n是，喜欢 Docker。\n一行 docker-compose up -d ，或者是 docker-compose down ，甚至是 docker-compose scale app=8 ，直接就撑起整个世界的感觉，真是极好不过了。停止与重新开启的时间不过几秒钟，真是让人很喜欢的东西。\n可惜了，它和 Windows 相处还不怎么友好，这又是个痛苦的面对，自己 Mac 开发玩可以很爽，可运行产品的环境竟然如此糟糕，不能忍，但又没辙。\n是开发者，忍受得了千万种折磨。\n同时，也是用户，喜欢简洁明了的操作体验。\n不知道这世界明天会走得多快，没有什么是理所当然。\n",
        "date": 1504310400,
        "objectID": "836da7c63543f02864cc6a801b81fc99",
        "relpermalink": "/python/2017-09-02-%E5%8A%AA%E5%8A%9B%E6%8A%95%E8%BA%AB-python-3-%E7%9A%84%E6%80%80%E6%8A%B1/",
        "section": "python",
        "title": "努力投身 Python 3 的怀抱",
        "size": 1786
    },
    {
        "content": "技术，是个好东西。\n有能力利用技术造出一些有用的东西，也是再也欣喜不过了。\n我们都知道造房子有点难度，构建高楼大厦就更加有技术难度，从设计到施工，没任何人全能精通。造汽车就也难了，虽然也是从设计到制造，可知识又是数不过来的多，更不用说制造经验和制造水平。\n能清晰解释出差速器原理的，也是不错了。\n可是，当轮到复杂度同样不比造房子造汽车底多少，有时候甚至更为复杂的编程领域时，为什么大家就不觉得这有什么难度了呢？\n 我觉得这个没那么复杂，你这样，这样，然后这样……，不就可以了嘛，我认为理论上是肯定可以的，你就照我说的做，到时候看到问题我再告诉你改哪里……\n我不管技术上怎么实现哈，我就只说我的需求……\n我想要你实现我把这个处理完的文件在手机上就能直接发给别人，这样我就不用还去开电脑了，晚上谁还不是想躺床上拿手机点几下就把活干完的……\n你这个一两天肯定是做不出来嘛，半个月你能不能做出来……\n 我觉着我要是能半个月定制化做个订单系统出来（仅仅后台 API ），我也觉得我完全能配得上 professional 这个词了。\n可惜，认清现实吧。\n一周，也就结识了个多级分类。\n至于，造一个多级分类到底有何难度，我也无法解释清楚。\n至少，这并不是一棵树而已。\n好了，多级分类搞得定，后面也还是好说的。\n未来，这个简单实现的多级分类看要不要开源。\n&ndash;\n人说，不要重复造轮子。\n可惜真相是，先不说没有合适的轮子可用，假使有，那么也得懂的轮子的一些些细节，才能正常使用吧。\n见过给桑塔纳上三一重工的轮子的么？\n好了，自己的轮子能用了，收一收，再这样下去，女朋友都该跑路了。\n",
        "date": 1497398400,
        "objectID": "b559635763c5e85d2a8b2e7c15e05f07",
        "relpermalink": "/python/2017-06-14-%E9%80%A0%E4%B8%AA%E8%BD%AE%E5%AD%90/",
        "section": "python",
        "title": "造个轮子",
        "size": 1448
    },
    {
        "content": "住在山边边的一个好处是离道路远些，路面噪音会少一些。\n离树木近一些的好处是一眼过去便是自然，空气会稍微好一些。\n然而期望值还能有多高呢，仅此而已罢了。\n却，有件事情不得不提一下：Bugs 。\n它们总是在某个不明所以的时间里闯入，然后等你看到，躺尸在地上。\n不能碰它，它并没有逝去。\n不能靠近它，或许会臭你一脸。\n如果，不小心翻它过来，它还是会爬，也有可能会飞。\n我不是那种见到蚂蚁如果踩到会认为是荼毒生灵的人，但是，这 Bug ，是我干不掉它。\n我只能认输。\n但是，这是什么大不了的事情呢？\n不，出现在这里，是绝对有原因的：它是雌的。\n你问我是怎么知道的，颗颗，自然不是我用看的，而是，我猜的。\n如果见到一只 Bug ，而立马要做的事情其实是：检查毛巾是否有被异物附着。\n为此，也废过一些毛巾。\n偶尔，还会出现在晾晒的衣物上面，可这还能怎么办，当然是选择原谅它：并把虫卵撇下来冲入下水道。\n至于蚊子、蜂，等等各种飞虫，还是少见勿怪了。\n住在森林里？别逗了，都不够喂蚊子的。\n—分割线\n同样有 Bug 的困扰，可有些能干掉啊。\n如果，面对一个总跟你说“我觉得这个其实很简单，你可能想太复杂了，你看这样……”，但是又不相信统计学知识的老板，你该怎么办？可是偶然间还会兴奋地谈起人工智能，这又是要闹哪样？\n我能闹怎样，当然是选择原谅他咯。\n这世界，谁容易呢，没谁。\n",
        "date": 1495411200,
        "objectID": "75dd8fd19fe89d09becb0987b59bb71e",
        "relpermalink": "/post/2017-05-22-%E9%82%A3%E4%BA%9B%E9%97%AF%E5%85%A5%E7%9A%84-bugs/",
        "section": "post",
        "title": "那些闯入的 Bugs",
        "size": 1234
    },
    {
        "content": "去售后取回了新的iPad，世界之窗的星巴克还是不适合久坐。\n所以想着去个新的地方，华侨城或许是可以的。不过在去的路上来到了华侨城这边的一家星巴克，感觉还可以。\n所以，现在已经坐了很久了。\n去年的6月1日，在茶话会上我说在这个时代，要去做一个创造者：Creator。\n记得在很久之前，我曾说，我从心里敬畏程序员们，因为他们可以将这个时代的很多想法得以实现，并在一个普通人难以想象的高度，解决问题并创造成就。\n马上就也快6月了，从意外地有机会真正开始进入职业编程，半年过去了呢。\n某种意义上来说 ，对于这种境况，我们需要定期与不定期地回望过去，审视一下在已经过去的这么久时间里面，到底发生了什么事情。\n然后在这样的回望和审视中，一边是想验证下自己是真的已经有足够能力赋予它未来，一边也是想想是否存在心底里的不安是否已经真的过去。\n实际上发现，不安依然存在，而是否可以足够赋予未来，有希望，但是还是不足够确信。\n这说了不等于没说一样么。\n是的吧，在一切的不确定中前行，是最有意思的生活。\n&ndash;分割线\n自从微信开始有了新的朋友圈控制规则之后，很多人都开启新的设置，当然也包括我，何况我为了完成一个类似的模块，还反复研究了很多背后的数据逻辑。\n从一个产品的使用者，变为一个产品的背后编码人员，着实需要跨过一座很大的山。\n逐渐地，我觉得会更加地对处于自己领域之外的东西需要更多的敬畏感了。\n对于职业，需要有些敬畏之心才是。\n不过职业与职业之间，都有些许的联系，在需求与产品之间，有很长的路要走。\n只不过，在短期，我们不应过低估计事情的难度，而又在一个较长的时间上，我们却不应对一个事情的实现难度预估过高。\n",
        "date": 1495238400,
        "objectID": "3bc84116e1b59b43450ce0a2b8eede53",
        "relpermalink": "/post/2017-05-20-%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E5%88%9B%E9%80%A0%E8%80%85/",
        "section": "post",
        "title": "成为一个怎样的创造者",
        "size": 1478
    },
    {
        "content": "你爸为什么今天还加班呢？\n有时候是会加班\n你英语这次考多少分呢？\n忘记了……让我想想……嗯……98\n你哪里错了啊？\n判断题那里\n为什么错了呀？\n它那个意思不是那个意思\n……\n《顺便帮朋友接孩子放学》\n",
        "date": 1493337600,
        "objectID": "fc756657537d02cb645fa785762de1da",
        "relpermalink": "/post/2017-04-28-%E9%A1%BA%E4%BE%BF%E5%B8%AE%E6%9C%8B%E5%8F%8B%E6%8E%A5%E5%AD%A9%E5%AD%90%E6%94%BE%E5%AD%A6/",
        "section": "post",
        "title": "《顺便帮朋友接孩子放学》",
        "size": 274
    },
    {
        "content": "2004 年进入高中，正式开始接触网吧，而后不久学校每间教室开始安装电脑，而后开始组建起专门的计算机教室，带网的。\nQQ 号就是那个时候同学帮忙申请的，就一直用着了，而后自己也申请过一些，都几乎忘记和放弃使用了。\n2007 年进入大学，有机会去网吧的机会多了很多，但是，网吧的设备比计算机教室的条件差很多，硬件和软件都差很多。也是同年，学校新开几个计算机公共教室，收费使用，差不多就是网吧模式了，一般都由申请学校补贴的同学们管理着，等于拿时间换点生活费，要是喜欢计算机我觉得可以，要是不喜欢的，我认为是不必要的，现在看来，一切拿最宝贵的时间换低廉的回报的，都不值得。\n那年，买了当时新出的很贵的 Mp4 ，各项指标都很不错，是当时所能买的起的最好的东西，然后就开始了倒腾的进程。音乐下载、转换格式，视频下载、转换格式，电子书，图片，不是在下载的路上就是在转换的路上。\n网吧的机器都是无盘系统，学校的机器有盘能保存东西，但是系统一旦重启后一样会复原，经常把机器折腾蓝屏。至于它为什么会蓝屏，以及为什么会有很多机器一直处于开机就蓝屏而无法继续，我的确未曾细细思考过。Windows 当时都是如此，习惯了都。\n那年某天发现自己的手指已经在键盘上飞梭了好一段时间了，而之前很长一段时间还在思考手指到底如何才能按照理想分工各自就位。\n那年某天，看到了苹果的官网，被里面的视频吸引。一个穿白色衣服的男子，没多少头发，用很磁性的声音说产品的制造，然后穿插一些工厂的机器切削加工的视频，看起来很厉害的样子。说的，是 MacBook 。\n是的，那个人现在依然还在这样宣传他的产品，发布会不会看到人上场，却总是在视频里面露脸，你去看视频就知道我说的是谁。\n那年，iPhone 发布了，后来我也只是听说很贵，很贵很贵就对了，后来还几乎买不到，有人没日没夜地排队。\n偶尔，我还会无意间访问到苹果的网站，但是还是没概念，没有见过实物，也没机会见到，小城市没有市场，大家也不知道，自然也没有人销售，或者，是我不知道而没遇到而已。\n后来那几年，与电脑接触都是上一篇提起的那些，自己没有，然后又却会帮别人弄。\n后来我想，在没有一样东西而又非常想拥有的时候，是最有动力把它的一切都了解的清清楚楚，能张口就来提笔就写，头头是道。\n但是仍然离真正使用它还有很远的距离，你所了解的，只不过是别人的说法而已，在网络营销被商家注重了之后，你甚至看到的都是商家发出的营销内容，用现在的话说：你被套路了。\n毕业后几年，也不知道哪天开始看到「池建强」在说 Mac ，还有一些关于那些人的故事，最开始在哪里忘记了，难道，是微信公众号？\n也看到「鬼脚七」在谈及自己如何步入技术的圈子，后来，又看到他开始走向另外一个行业。\n而我，只是一个看客，他们不会知道我的眼睛在看哪里。\n其实，促使我最终决定拿下 Mac 的主要动力，其实来自于 Keynote 它可以制作精美绝伦的幻灯片，可惜，自从买回来，它就被挪去做别的事情了，Keynote 也没能打开过几次，好像这事儿就从未在脑海里出现过一样。\n是的呢，本是奔着某个点去，却沿路又发现了更多的路，风景美不胜收。\n走一路，看一路，但，我们最终会在某个时刻抵达最初的那个点不是，至于需要停留多久，已不重要了。\n有一个字：撞。\n如是说生命的火花需要激情的碰撞，不如也说生活不是列车时刻表，你与它时间，它与你惊喜。\n只要是好的，那都会是好的。\n",
        "date": 1488326400,
        "objectID": "8c0977de1d7addd2370439d63e9c44d8",
        "relpermalink": "/post/2017-03-01-%E6%88%91%E4%B8%8E-mac-%E7%9A%84%E6%B8%8A%E6%BA%90/",
        "section": "post",
        "title": "我与 Mac 的渊源",
        "size": 2900
    },
    {
        "content": "首先在发上一篇「春节随想」的时候，那时候会想可能接下来会就里面的一些话题作一些展开，不过今天看，我暂时就不写它们了，写点其它的。\n已经过去的这个周末，弄了一件事情：把一台性能够用但却已近乎被放弃的笔记本电脑从死亡边沿拯救回来，用主人公后来的话说是：它又活了。\n所以，这也算是大学那几年的折腾，曾经付出那些时间，在今天依然能体现出的效用吧。\n如果往前追溯，我想我了解到有「计算机」这个词的时间，应该是在小学六年级，几节不那么特别有趣的课，和一本小小的册子书，后来几年中，好像还时常能看到它冒出来，现在它在哪里，我应该是不知道了。\n在后来的很长一段时间里，大概持续五六年时间，我一直认为未来我可能不会有多少机会手写字了，因为，如果既然有了计算机这么厉害的东西，用它来写字，会是多么厉害的事情。\n当然，后来确实是如此，科技改变了很多东西。也让我，现在连名字都不会好好写了，还好签名可以个性化，哈。\n现在，我尽瞎折腾：做程序员，写点代码，了解互联网web技术，将来做做网站，做做数据处理和分析，以及自己随便玩玩看似有点难度的东西；或者学点设计，折腾下图片、音频、视频，还有文字。\n如果往回看，今天的选择可能在曾经的某日就已作下。\n曾经有人跟我说，你这么厉害可以去做程序员啊……\n或许，说者无意，听者有心了吧。\n2008年那个时候心心念想给自己弄台电脑，但是持续好些时间，这期间没能给自己折腾上一台电脑（还不是因为穷），倒是全学校到处跑别人宿舍做义务电脑技术员了。直到后来接近毕业了，自己开始工作了才真的买下了真正属于自己的第一台笔记本电脑，那欣喜的感觉至今犹深。\n至于过手的电脑的数量，我认真想想可能其实不是很多，毕竟有段时间与校外的电脑公司达成合作关系，由于自己对产品选择的想法以及并未将其作为重要的经济来源，而确实仅仅只是给身边朋友提供一些咨询服务的缘故，过手数量说出来可能都羞涩了。\n基于「科技改变生活」的理念，混迹于计算机硬件、系统、软件等类型网站，想想过去的那些时间，也是乐在其中吧。\n而现在，也慢慢地发现态度的改变，在认为把它们当工具的前提下，已经不推崇花时间去折腾这些东西了，能一次搞定，能花钱买好的，就尽量一次性买能承受得起的最好的那个。\n毕竟回头看过去的时间，发现时间才是最宝贵的，如果能不受经济所限，自然是尽早去冲着事务目标去行动才是，而不是被工具所限制而延迟了很多本该想做的事情和决定。\n其实一直想分享几个我所关注的公众号出来，不过一直没行动，因为多图文排版要编辑图片，虽然直接贴原始的二维码也是可以，不过我认为太粗暴了，虽然早期他们也是这么干过。\n然后，想分享我关注的，主要也是想借他们来表示下我的一些喜好和观点，作为朋友，除了吃吃喝喝，还是要了解点想法不是，所以等我下次写吧。\n今天我把底部菜单更换为了我个人的二维码，点击「加微信」就能收到一张二维码，新来的朋友可以加一下。\n要是没有什么特别的考虑的话，我想，最先100位订阅，就作为种子订阅用户吧，超过一百订阅之后我就把它撤下来。\n当然其实还可以有另外一个想法，我觉得我可以一年接待5个人以内的计算机咨询业务，基本的可能会是提供选配咨询服务，如果有必要可能也提供面对面拆封组装，以及一些系统与软件安装，当然也可以额外提供一些使用建议和软件使用等（我有所了解范围内的知识）咨询，至于既然是服务，那么就是要收费的，但是收费标准嘛，完全看人看心情，不过可以给个数字作参考：50/h。如果你有需求，我会先给你洗脑我的理念，如果你愿意，咱们再谈事情，嘻。\n有钱才能任性。\n",
        "date": 1488153600,
        "objectID": "2c1a6653edc0857737a8525745b394dd",
        "relpermalink": "/post/2017-02-27-%E6%88%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/",
        "section": "post",
        "title": "我与计算机的那些事儿",
        "size": 3006
    },
    {
        "content": "11年11月抵达深圳这个城市，至今已好几年过去。\n最初的两年，由于一些原因而未在春节回家，也因此，给人留下了我专门过年不回家的印象。\n不过，不必辩驳什么，有时候回，有时候不回，自己也记不清，别人当然只能记得不回的那些事儿。\n好的，都会记不住，不好的，总是印象深刻，脑子就是这么使的，毕竟，在动物时代，记住不好的，能使下次避免伤害。\n其实年龄渐长，已有能够预估到执行一项事情所会遇到的境况了。\n不过，还是既然决定了执行，就执行就好了，把关注点放开一些也就足够应付了不是。\n其它的不想多说了，今天，发点特别的。\n在那十几天的时间里，会遇到一些事情，和一些情景，而方便的时候就在当时记下了几句随想，而不方便的，可能就没能在这里留下记录了。\n机身没有弹孔的飞机我们都看不到，因为已经飞不回来了。\n下面是随想记录，只字不删，原原本本。\n 物质贫乏必定带来意识的贫乏，而自我意识的变化需来自外部环境的改变，这便是外部环境的重要性所在。 大概在初中到高中时候常听同学们和我说，你改变不了世界就去改变自己适应世界，我时常以为这是消极的想法，你想，生活在这世界，哪里能不会改变点什么呢，现在想着，其实对于生活的无奈和对世界的失望，不必一定要改变它或者又让自己改变而适应它，其实，可以让自己换一个更好的环境，一个你会喜欢的环境就可以了。 逃离贫困的地方，不仅仅是指的物质贫困，更加指的是意识贫困。\n孩子是大人的投影\n对方是自己的投影\n人们为什么会喜爱“烟雾缭绕”\n极小时候你任性的表演会让她们突然想送你去学舞蹈美术音乐，但是在你自己选择的时候却未必会支持，甚至是业余都不会。\n什么样的浴室（卫生间、洗漱间）会让人觉得有生活气。\n东风牌大卡车 我头上的仍旧明显可以摸到的疤痕深刻地提醒着我曾经历过的那一场车祸\n朋友说我内心是苦的\n人要出门，天要下雨，菜花点了点头。\n做事儿不靠谱，就会打嘴炮。别怪我不待见所谓老乡。先证明做人做事靠谱才行。MLGBZ\n茶陵的某些人们就是不仅可恶，还傻得可恶，蠢！stupid！\n所谓有那么一部分的本地人，他们的可恶可恨之处在于他们不仅仅遇见外地人见一个宰一个，更加的是他们对本地的人更是没有做事的方式可言。\n第一，我不相信任何人的自身素质和自觉性。 第二，我不会相信任何所谓老乡的职业素养。 除非，你已证明你值得信任。 看到高速路和高速服务区你就理解了。\n ",
        "date": 1486512000,
        "objectID": "c0f5e36cc26cc3eb4d6357383f7408da",
        "relpermalink": "/post/2017-02-08-%E6%98%A5%E8%8A%82%E9%87%8C%E7%9A%84%E9%9A%8F%E6%83%B3%E5%A4%87%E5%BF%98%E5%BD%95/",
        "section": "post",
        "title": "春节里的随想备忘录",
        "size": 2042
    },
    {
        "content": " 关于即将决定要去学习的IT类技术 自从15年决定开始正式学Python来搞事情，今年，也算是进入了第三年了，进入全职工作，所以真枪实弹地搞事情，实力自然会上一个台阶，至于过程，就都丢给时间和机会去磨砺。\n现在主要做的事情是网站后台服务API的开发，搞懂这背后的事情，就基本搞懂了后台服务端。\n计划增加这些任务：学习JavaScript、CSS，深入学习HTML。\n解决后端的事情，利用API提供统一服务，要完成运行一个完整的网站，还要搭前端，这是最终看见的东西。\n而它的技术栈，就涉及到上面这些术语，所以，筹备前行。\n关于爱情与婚姻 近些时候，嫁对一个原生家庭会如何幸福的文章很是得人心而大范围转发。\n而我，恰恰是没有如此机会能在一个美好的家庭里面成长并获得来自父亲母亲方面任何关于爱的潜移默化。我并非出于对此文章的辩驳，而是想，即使我们已然没有机会再从父亲母亲那里学到关于爱的任何信息，也不必因此气馁，否则，就应该直接放弃念想了。\n是，我也一直怕，一直畏惧，一直自卑，而甚至在我的脸上，直接就能看到那些岁月写下的印记：不会怎么笑，也笑得不多，不笑的时候完全像是在生气，就像被人欠了好几个亿，即使内心冲动也不明于表，即使内心激动也无法表现于形；言语上表现更是极为抠门，能听到赞美是一种奢侈，而冷言冷语却总是不经意就脱口而出，叙述一件事情就好像在跟人吵架，也从来讲不好一个故事，语言上带感情这个事情几乎就好像只有冷漠；开不起玩笑，任何事情都能整出一脸严肃感，动不动上纲上线。还有许许多多……\n但是我也有理由相信，保持对生命的敬畏感，人生每时每刻都会发生变化，逃离曾经历过的熟悉的氛围，接收来自外界不同的信息，并形成持续的改变，我相信是可以的。\n不会存在完美，但是可以相信变化，可以逐渐地变更好。\n对自己说些具体的：\n 放弃持续做简单的抱怨而是去持续尝试使它变好的行动，哪怕最终只变好了那么一丁点，甚至完全失败，也没关系； 尝试建立交流反馈而不是完全拒绝沟通，因为拒绝沟通对任何人都是死结，可以直接宣布死亡了； 不一条路走到黑，尝试退步让路，不争论不休，即使真的对方错了也不必在当场压死； 承认自己不是那么聪明的； 说出自己的困惑和压力； 如果真走不下去，该放手就放手，双方都是； 如果有孩子，告诉他真实发生的事情，如果时间不允许就晚一些，持开放性态度接纳他的存在，并自己做自己的样子，让他知道即使父亲母亲没有能在一起也是最好的选择； 如果以上都做不到，就过好自己，对自己好点，并跟大家承认自己做不好爱情或者婚姻这事儿，但至少还能做个人； 每个人都是不一样的，不以自己的标准要求人，也不严格以莫名的社会水平要求自己，但尽量不要太反社会； 在能力范围内，选最好的做最好的，如果不知道什么好，就去想什么才是好的，总是随便将就是不太可以的；  其它或许还很多，也有一些额外补充不仅仅对自己的：\n 性是可以谈的，也是可以做的，但是也要认真做功课的，和其它事情一样，平常对待就好； 我是不介意曾经的，但是此刻是排他的；  其它想到一些关于婚姻：\n 二人关系首位，其它靠边； 理应有些自私，自己家过好，才能有能力考虑他人家  先这些吧，如果说错，请点名。\n关于生活 保持好奇心，保持对新事物的兴趣，书，要多看，越多越好，也更要实践去玩。\n其它写不明白，这个题目太大，就仅上面这句吧先。\n哦，当然，运动要经常去，要对自己身体负责。\n要去很多地方走走。\n其实，宅一段也是不会有什么不好的。\n在一处，做一处的事情，持一处的心。\n",
        "date": 1484438400,
        "objectID": "5c284cc1449a7bab9e616cf48d5105fe",
        "relpermalink": "/post/2017-01-15-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85%E7%9A%84%E4%BA%8B%E6%83%85/",
        "section": "post",
        "title": "关于一些事情的事情",
        "size": 2982
    },
    {
        "content": "凌晨一点半，环卫工人在为马路中间的绿化带种花。\n司机跟着导航，不知所措地闯入了单行道，转头走入深南却又发现不可左转。\n晚上的凤凰路还是灯红酒绿车水马龙，等到发现了前面路被封住，只好下了车。\n司机说明天就要回去，而本来，是今天，如果是，这个点应该早已出了广州。\n我并不想继续问他要回去哪里，就是，他老家在哪里。\n你一路平安就好，载完我，就回去早些休息吧。\n吃饭，喝酒，唱歌，喝酒，拼骰子，喝酒。\n没有别人家的公司那样的年会节目，没有费心劳神的节目排练，没有你们费尽心思等待的抽奖环节。\n如果做不到有心安排，那就这样简简单单吃吃喝喝，我觉得已经是挺好的。\n只要老板您这个时候不表现得抠门，只要您这个时候一脸豪气，放开胆指点江山，咱都愿意。\n不折腾咱就是挺好的。\n点歌。\n仅有的几个羞涩的女孩子们表现的并不积极，这与预想的不一致。\n老板娘积极，非常好。\n这里中间略过几个小时。\n酒过几轮，女孩子们走了，然后歌过几轮，老板一家三口走了。\nIT男们发现时间还久，不唱对不起这机会。\n笨小孩，我们来了。\n突然我才发现，时代的印记，它是那么的明显。它无时无刻地都在，不断地在每一处表现出来。\n在我与我之前的那个时代的孩子们，爱情是奢望，是奢侈品，游戏也是奢望，一切新奇的事物都是奢望。\n而已经离开并回家的那些年轻的女孩子们，歌里的爱情是自然就已存在的，而诉说的，是爱情的苦恼。\n我们是浪人，即使曾拥有一段短暂的爱情，也知道始终自己是会要离开某个地方，然后，爱情就成为过去。\n它是奢望，它是会成为回忆。\n然后发现时代的变化，远超自己世界所处的位置。\n还是依然一个人头也不回地，即使走远了默默流泪也不会让人看到么？\n这坚强而又内心柔弱的我们。\n不知道第一次被同龄人认为：一看我就应该是属于90后的，我该做如何感想？\n就让我先偷着笑一会儿吧。\n微信乐库没有华仔的版本，点击「阅读原文」去听吧。\n",
        "date": 1484352000,
        "objectID": "0870fc5cf9e7be116f467b1d6851ff2e",
        "relpermalink": "/post/2017-01-14-%E4%BB%8E%E5%A5%A2%E6%9C%9B%E7%88%B1%E6%83%85%E5%88%B0%E4%B8%BA%E7%88%B1%E5%BF%A7%E5%BF%83/",
        "section": "post",
        "title": "从奢望爱情到为爱忧心",
        "size": 1648
    },
    {
        "content": "第六周快过完，写完又测试完了5个API，大概分三个项目完成，今天刚完成第三个。\n又预备开始下一个“小”项目。\n说小，是格局小，而又很大，如果格局放大来看的话。\n不论将来多大，且看且行。\n说，写出来的都是过去。\n是因为，事情做完了，松一口气，刚好会有机会回望过去的时间，然后，再转头望向未来。\n我总是以为我能在事情完毕之后能说出点什么，然而并没有。\n几乎等事情差不多快完毕的时候，目光已经开始转向下一个目标。\n不过还是可以回顾下之前的某些时刻。\n之前说，带上恐惧前行，我想是确实有必要的。\n在好奇心已经无法支撑起前进的步伐，那么靠恐惧来推动，是现实的做法。\n只是，如果不能Hold住这种恐惧，让我很怕的事情就是被恐惧压垮，身心俱疲。\n我又是想多了吧，想项目多时候，我就是往多极了想，然后再被打回原形。\n这样也挺好的，务实。\n其实好像还有一些其它事情总是在某些时候在脑海里冒出来，然而等到能有机会写的时候，几乎又消失得全然不见。\n所以就先这样吧，能写什么就写什么，不该对这个有顾虑。\n今年，会随回乡大军回家，来年又随大军回城。\n其实等那会儿已经2月了，也不必介意吧，不就是2017而已。\n下次，还是有想法就行动起来吧，无论什么；很多事情，会被时间抹掉的。\n",
        "date": 1484179200,
        "objectID": "f19eb892899cfbf32e9e13cef89ee926",
        "relpermalink": "/post/2017-01-12-%E5%86%99%E6%9D%A5%E7%9A%84%E9%83%BD%E6%98%AF%E8%BF%87%E5%8E%BB/",
        "section": "post",
        "title": "写来的都是过去",
        "size": 1126
    },
    {
        "content": "2016就快过去了，而我总是写不好这四个数字，无论今年在多少本书上面曾写下了它，就如同我也写不好我的名字一样，毕竟如今我连字都不会写了。\n这张图片，现在看起来，我觉得里面包含着我个人今年的许多信息。我持续地在思考着一些事情，一些关于曾经做过的一些事情，所以我今天又打开它来看，并截下了这张图。\n这些年，我更加坚定地认为当前所做的一切都将在未来某个时间，让你回头的时候，发现很多事情，在很久以前，就已经悄悄地埋下了种子，而当时并不会认为这会有多么大的价值和明显的用处。\n或许是因为一个无故的起因，或许是因为不那么明显的一句话，也或者是因为曾路过某地，无意间目光瞟过的某些瞬间。\n这一切的一切，都有它的无形而有无处不在的意义。\n我对一切寄予极度地悲观之态度，而又不断给自己寄予无尽的希望之光。\n这，是极度地自私。\n所以，无论如何我都会错过太多身边的一切，有意无意地望着它们从我身边远去，有心无心地悄然离开它们。\n只好说，祝安好，也祝自己安好。\n当已悄然远行，并不会告之你们我将要去的目的地。\n经历了什么，错过了什么，又有了什么悲伤，又有了什么喜悦，都将随时间而不断流走。\n抛开曾有，不顾一切，没有选择，便是最好的行程。\n你们，请与我，一起，走向2017吧。\n注定，我们将还会走过许多年。\n",
        "date": 1483056000,
        "objectID": "b64a03a4d04fbdaee3a0467ca9065453",
        "relpermalink": "/post/2016-12-30-%E4%B8%80%E5%B9%B4%E5%BF%AB%E8%BF%87%E5%8E%BB%E4%BA%86%E8%BF%98%E6%98%AF%E8%A6%81%E8%AF%B4%E7%82%B9%E4%BB%80%E4%B9%88/",
        "section": "post",
        "title": "一年快过去了还是要说点什么",
        "size": 1158
    },
    {
        "content": "明天就是平安夜，我打算今晚啃个苹果。\n以程序员的角色上岗工作已经正式3周过去了，这算是正式地公告一下。\n放在几年前我从未想过我会正式地成为一名可以自己编程写代码的人，可是在这几年的工作中逐渐地接触到一些事务，使得我认为在未来的日子里，不会自己写几行程序代码的人们总是会有一些很难过的坎儿。\n所以，无论将来如何变化，我先去坑自己一把，把编程这事儿彻底地扶正了来做，再也不是什么随便搞搞就行的事情了。\n但是说回来这事儿还真不是会不会程序语言语法这么简单的事情，学会了使用写法只是冰山冒个尖儿，下面水很深，路很长，坑更是多不胜数，我只能寄希望于天兵天将们不要懒惰。\n这儿说，关于思维方式。\n或许是我开始学习Python的时候，就接触到的都是：\n如果True，就去做什么，否则，就做点什么。\n然而今天深入到别人的项目中之后，基本上都是：\n如果不是True，就做点什么，否则，就去做什么。\n这使得我很困惑啊，脑子现在还晕。\n就这么绕啊绕，不知道死了多少脑细胞，反正也没法具体数，你就给个超级大的数字就好了。\n所以，啃个苹果清一清神儿吧。\n祝平安夜幸福，祝圣诞节快乐，各位！\n新年见！\n",
        "date": 1482451200,
        "objectID": "f7dbc3fe77d0fa1485b5ac0c356a598d",
        "relpermalink": "/python/2016-12-23-if-true-or-if-not-true/",
        "section": "python",
        "title": "if True or if not True",
        "size": 1048
    },
    {
        "content": "吸星大法\n我们是在金庸的影视剧中长大的孩子，身边朋友有看金庸大部头长大的，我没有机会去看金庸的全本，只是在影视剧中看到一些这样或者那样的影子。\n而我，还看的不认真，对于角色与情节，并说不上什么话来，可能还错误百出。\n然而人脑确实是个神奇的东西，昨日回程路上一边想着晚上可以吃啥，一边也在想着：如果有机会进名门正派做入门弟子，从一招一式，一剑一掌开始学起，比如少林，比如华山，那就如同高中考上了好学校，有进了好专业，同时要是运气好遇到好师兄，那基本修炼成上乘武功，内力深厚，前程似锦，平步青云，只要自己不作死，那必定是处在山峰之巅，被人可望不可及的那种，即使未来不在武林称霸，也是足够有资本在武林之中留下姓名，凡人谈及就敬仰不及的。\n然而，也有很多人在之中并无建树，一场小小对战可能死伤无数，成为他人嘴中无心顾及的炮灰，你一个人的性命，倒不是他们这些正派武林人士所需顾及的事情。\n如果，要是没有能考上好大学，也没有能在一个好专业，也可能并不在自己所擅长的领域里面，或者是自己喜欢的领域里面，自然可能遇到一个牛逼的好大师兄的机会不大可能了吧。等些时日，要出去闯荡江湖，却发现自己所学全无用处，内力不及人家之万分一，还未近身便被打得倒地不起。\n这是否就该找个无人的地方了却余生以谢不杀之恩。\n完成任务\n如果没有了了却余生的想法，路遇恩人，得一席之地安身，那便开始了与上面那群人完全不一样的路程了吧。\n拿到一个任务，绿林的人们知道自己不会有那么雄厚的资源可供使用：怎么简单怎么来。\n可是，逐渐地发现这始终会有问题，等过一段时间，到处救火救急，忙的不可开交，却不知道自己到底可以在什么时间能有新的发展空间。\n虽然说怎么简单怎么来，可是有一个前提，就是：真的了解了需求的具体情况，而不是想当然地认为按什么样的最简单的方式来操作。\n一个需求，可能一句话简单说说就听过去了，在没有形成成熟的流程并经历过各种考验的团队中，基本上可能完全看接受这个需求的团队的自由发挥能力。\n然而一个需求是有它的本质动力存在，知晓它的本来目的，才能分析出它背后需要涉及到的功能设计，然后围绕这些功能，通过各种技术底层的构建，设计流程，构建数据，最终完成此次项目的完整实现。\n为什么要去问它的本来目的，是信息在传递的过程中肯定会存在偏颇和丢失，沟通的多少在一定的程度上决定了未来这个项目的发展能力。\n设计一个功能，本质上是为了未来而设计的，是期望它在未来的一定时间里面，助力它所在的那个整体之中得到一定的发展速度。\n这就如同，买电脑要大概稍微考虑未来2年的需求，买其它的任何东西，都相应地要稍稍留出一些些空间为未来考虑。而完全不留任何未来空间的想法，在很大的概率上可能在买回来拿到手的那一刻，它就已经有些无法跟得上世间的脚步。当然有一种例外，就是短期用完就完事儿这种。\n当然会说要考虑到预算问题，可是其实仔细想想，比起那些未来的时间，眼前的这些超出的明明可以承受的那部分，根本微不足道。\n虽然在现在这个时代，我们很多事情都讲究速度，但是是眼前的速度，还是未来可预见的一段时间的速度，这个需要人们这个复杂的每个个体去花上时间思考。\n它毕竟决定了未来的发展能力。\n完成一个任务绝不是仅仅完成任务那么简单，无论是对项目本身还是对自己，它都是提供未来发展的机会。\n既然我们已经没有了之前的很好的那些好机会好平台好环境，我想，把眼光和目标放在那些可及的高一些些的地方，用上吸星大法接受来自大量信息的轰炸，并等待时间和成长去消化它们，勇敢地想多一些，做多一些，虽然可能会面对失去很多的悲伤，但是相比起得过且过最终失落，我觉得可能是会好那么一些。\n每次都超出能够得着的那么一些些，等到未来回头，才能发现已经走很远。\n在曲折的道路上蜿蜒前行。\n",
        "date": 1481932800,
        "objectID": "acad6d7212ec483e157024a25c954bdd",
        "relpermalink": "/post/2016-12-17-%E5%8B%87%E6%95%A2%E6%83%B3%E6%9B%B4%E5%A4%9A%E5%81%9A%E6%9B%B4%E5%A4%9A/",
        "section": "post",
        "title": "勇敢想更多，做更多",
        "size": 3164
    },
    {
        "content": "上班第二天，面对一切，毫无头绪，也同时又些事情，需要妥协，就当为一次机会。\n面对陌生，总是恐惧。\n有时候不敢回望过去，过去都是恐惧的影子，挥也挥不去。\n可这也难免就会在某个不知明的夜晚，它们突发情绪，让你以为这就是跌下悬崖的时刻。\n有人说，营销带上恐惧，便有了爆发的可能。\n确实，买各种东西的时候都是带着恐惧而按下最后的确认，那是对未来欲望的恐惧。\n有恐惧便有紧迫感，很怕很怕的，担忧到累心，直至心疲力尽。\n雾，散不去，朦朦中看不清前行的石子路，又或是泥泞小道，不注意就摔个趔趄，又用手摸一摸脸，还好，没事儿。\n泥巴盖去了划开的口子，继续赶路，忘记了疼。\n走一天，便有一天的希望。\n走得远了，就忘记了害怕。\n",
        "date": 1480896000,
        "objectID": "433acabce7926bc143dd16b919632a0c",
        "relpermalink": "/post/2016-12-05-%E5%B8%A6%E4%B8%8A%E6%81%90%E6%83%A7%E5%89%8D%E8%A1%8C%E6%9C%89%E5%A4%9A%E8%BF%9C%E8%B5%B0%E5%A4%9A%E8%BF%9C/",
        "section": "post",
        "title": "带上恐惧前行，有多远走多远",
        "size": 682
    },
    {
        "content": "无论是否是因为我带的MacBook Pro在帮我镇场，还是无形中有个意识在提示我晚一点再写，先去洗漱完再推新版，总之，现在，我不改它了，就让它默默地在哪里挂着吧。这也算，是这一段经历的记录，以及，它所需要经历的过程。\n明儿个，如果没有什么特别的意外，特别特别的意外，能让做出决定的事情中途变卦，如果没有的话，明儿个开始我就去上班啦。\n十二月的第一天，十二月的第二天，十二月的第三天，十二月的第四天，十二月的第五天……\n都是好日子。\n说一个额外的话题：进步与发展一定会是来自于外部。\n为什么要提这个话题，是因为，我昨天又收到了一本书「《Python Web 开发实战》董伟明 著」，看到这个「著」字了没，这在挑书届是一条不成文的经验：「著」就是自己写的，「编著」就是大家一起编写的。\n而至于「编著」它到底是大家一起写的还是大家一起“编”的，没有人知道。不是说编著的书就一定没有好书，而是说从人性的角度和成书的概率上来说，它，在较大的几率上会不那么靠谱一些。\n要不你去翻一翻曾经小学初中高中大学十几年的课本看看？\n还有去书店或者在线书店看一看那些鸡汤届文摘届看看？\n也不是说「著」就一定好。而是，这是个我在没看到书内容之前，挑书所考量的因素之一。\n为什么说进步与发展一定会是来自于外部，当他们所有人都认为有些事情是理所当然，完全无意识到事情的惨败程度，当他们所有人都觉得无力完成或者其实真的无力完成的时候，只有仅仅那些具备无所畏惧之精神的人们才会选择一记痛击，带来新的流动和血液，产生新的爆发力。\n写上面这本书的人，豆瓣的。\n他，不是IT专业出身的。\n他，以前最早做运维的。\n他，也不是原本就会Python的。\n他，曾也是只会shell也沾沾自喜的。\n直到，看到疼痛的差距，现实被刷新。\n如果没有特别的意外，我将进入预计2-3年期的专门技术领域深入。\n同时，对于我曾待过的电商物流行业，我依然有想法放出我特有的一些东西出来，不过这我不做承诺，具体如何，全凭机缘，但都需努力。\n奔跑吧骚年！\n",
        "date": 1480550400,
        "objectID": "bf986c839cd8562f06ac555f2ba30221",
        "relpermalink": "/post/2016-12-01-%E6%88%91%E6%9A%82%E6%97%B6%E4%B8%8D%E6%94%B9%E4%BA%86/",
        "section": "post",
        "title": "我暂时，不改了",
        "size": 1760
    },
    {
        "content": "我记得小时候家里大概在这个时候总是会攒上一大袋子橘子，个头不是很大皮又很好剥开的那种，然后就经常三个五个地从袋子里掏出来吃。\n具体叫啥名儿，或许我又不清楚了，或许是我们离江西近，有些苗子都是那边引进来的吧，江西的小柑橘还是蛮有名的。\n近些年，几乎很少有机会吃到，也没有经常要去买水果和零食的习惯，毕竟自己平常大多数时候不是嘴馋的货。\n下午接近晚上的时候，便出去走了走，随便走走便是十几公里，看来水库绿道作为深圳最美绿道也是可以的。\n这张图片，便是今儿个拍的。这个地方，我拍过很多次，也是来得勤快的缘故吧，每次都有不一样的效果。\n这天空的云，就如同橘子的红，透红透红的。\n人在空气好空间宽敞的地方，也足够有时间想清楚一些事情。\n我觉得，可能，暂时不应该盯着那些够不着的地方，但凡是什么「Python开发工程师」「大数据分析工程师」这些都不是我所完全能胜任的，我所面对的也不再是5年前人家看你足够有想法就能给个机会的形势了。\n昨天我问自己走了多远，我回头看了眼，貌似是好像走了一些距离，也经过了好一些关口，可是，再看看前面，依然还很陡峭，或许自己可能认为给个机会就能够个手了。可是，刚够个手，和站在那儿继续看下一个关口，这之间还差了好多个坑需要填。\n而这些坑，自然是不会有公司愿意替你填的，不能有这风险，必须要那些已经填完坑的。\n我又拿了几个橘子吃吃看，甜甜的，也看到一个坏了的，扔了。\n而小时候，经常就能翻到坏了的橘子。坏了，那就扔了。\n兴趣的归兴趣，我还是先去站着够得着的吧，这对双方都好。\n有得浪费，这是奢侈。\n只可惜，可能收入会低，暂时的。\n吹过的牛逼将来慢慢说吧，于我，更久。\n",
        "date": 1480464000,
        "objectID": "ebd2f21f5c998d15287977e66cbe2df9",
        "relpermalink": "/post/2016-11-30-%E6%A9%98%E5%AD%90%E5%8F%AF%E8%83%BD%E8%A6%81%E5%9D%8F%E4%BA%86/",
        "section": "post",
        "title": "橘子可能要坏了",
        "size": 1458
    },
    {
        "content": "眼看着就是30 November了，这天再过去，就剩2016的最后一个月。\n虽然，从农历计算还有些日子，然，我也是焦虑的。\n我不怎么管农历的事情。\n也表示，从9月底，我彻彻底底地度过了10月和11月两个月之久，这比我想象的要久。\n不说你也知道我最近在被什么事情困扰着。\n话说虽然从台湾回来想着是否要发一些照片让大家看看，不过，我总是觉得仅仅是发出9张普通照片或者是提供出一篇类似某窝好几年前的游记文章，我都觉得不符合口味。\n所以，这事儿，就暂时搁置了吧。\n说说一些其它的事情吧，还是。话说年龄到了这个阶段呢，或者是甚至再大一些比如三年后的我，曾梦想着生活会如同某个想象中的样子，如同电影那样。可是现实并不如此，我们看的是别人的生活，总以为自己能轻松抵达。\n啊呀我这是要说什么了呢……\n虽然我想着过去的生活都是过去的事情不值得去回顾或者回忆，然而总会有一些事情和状态会让思绪自己走到那些地方去，拦也拦不住。就偶尔来那么一下下吧，回忆会有让人有一种自己已经走了好远的感觉，可我到底又走了多远呢。\n我想走的远远的，远离家乡，远离熟悉的地方，远离曾经发生过任何事情的地方，特别是我愿意远离任何我曾生活过的地方。\n就如同，我现在要远离任何我曾工作过的岗位类型一样，曲折地，走着，或者说是爬着。\n爬山，我尽量每次走不一样的上山道路，在尝试过了很多次了之后，都熟悉了我就甚至可能不愿再爬同一座山了。\n不知道是否真的有某种特质会被人在很早就发现并认为可以去做，然后等到我在很多年之后，慢慢地发现正在朝着很多年前他们说过的那些话而努力着，那么现在，完成了多少。这是有意识地还是被他们的看法影响之后，然后就认为自己可以做到他们认为的那样呢？这这是个奇妙的逻辑，我要不要先吹几个气球上天呢，或许，哪天我就追上了它们曾有过的高度，只是，可能会很久，很久吧。虽然，吹过的不一定都需要实现，不一定都需要。\n如果，我能在感动自己之余，顺手带上几个朋友走入不可救药之坑，感动得稀里哗啦然后不明所以。\n如果，我真能在感动自己之余，顺手把自己吹过的气球都慢慢实现，不知谁能为我的生活付出生活费和未来孩子的奶粉钱呢，还有，买包的还没算呢。\n只可惜，我现在已经不买便宜的包了，又该怎么办呢。\n买不起了。\n",
        "date": 1480377600,
        "objectID": "6e858901163282d5024f9795c33a0ee7",
        "relpermalink": "/post/2016-11-29-%E7%84%B6%E8%B5%B7%E4%BC%8F-%E7%84%B6%E7%AD%89%E5%BE%85-%E7%84%B6%E7%84%A6%E8%99%91-%E7%84%B6%E5%A6%A5%E5%8D%8F/",
        "section": "post",
        "title": "然起伏 然等待 然焦虑 然妥协",
        "size": 1938
    },
    {
        "content": "首先恭祝F&amp;N乔迁之喜；打完火锅回来走出地铁站，发生如下一幕：\n将雨伞从伞袋中抽出，此动作应当如剑客般，面对迎面而来的对手，脚步急促有韵而沉稳，左手握鞘右手拔剑，双眼犀利有神，当剑起翘落，然后按下开伞开关雨伞随即展开，此时，淡然走向雨中留下身后无数功与名。\n回来深圳给我的感觉好像下了好久的雨，却然而被一同打完火锅的伙伴们提醒道：前天没下雨，昨天也是大太阳，一整天都是。\n我随即陷入了深深地沉思中。\n我们每天盯着APP查看目的地未来7天的天气预报，想象着会有某一天看到未来一段时间的天气能够完全与我们的预计行程安排会契合，然而这种概率貌似会很低，但是希望是仍然需要有的是不是，万一，有了呢。\n天气预报的准确率有多高我无数据支持，但是比起很多年以前来说，理论上应该是准确了许多就对啦。\n可是出门看天的习惯依然是作为必备技能随时展现，走一步看一步天，然后等着掉入坑里。\n掉坑不是真的掉坑，是自己挖坑自己填，坑和坑还是有区别的。每走入一段旅程，都是为自己开启一个新坑的开始。\n然而神奇幸运的是，看到我晒黑了，这我得告诉你，出门在外的加起来近一个月的旅程中，我却并无遇到不适合出行的天气。\n我走到哪儿，天气都是好好的。\n可是，现在，它下雨并没有想停的意思。\n所以，这应该与我在哪里并无什么关联。\n而我曾，这么以为过，至少有那么一会儿有人说自己走到哪儿哪儿就下雨我是半信了的。\n我现正在找工作，如果你觉得可以内推，点击下方「阅读原文」 即可在GitHub查阅我的简历\n",
        "date": 1480118400,
        "objectID": "05b6ef4afed82ce87f09343c490e6a1f",
        "relpermalink": "/post/2016-11-26-%E5%AE%83%E4%B8%8B%E9%9B%A8%E8%B7%9F%E6%88%91%E8%B5%B0%E5%9C%A8%E5%93%AA%E9%87%8C%E5%B9%B6%E6%97%A0%E4%BB%80%E4%B9%88%E5%85%B3%E8%81%94/",
        "section": "post",
        "title": "下雨跟我走在哪里并无什么关联",
        "size": 1340
    },
    {
        "content": "从9月底到11月底，中间度过了两个月。\n两个月，经历了两次间隔不久的旅程。\n一次，从湘西走到川北，再去到雾城。\n另一次，从岛西绕到岛东。\n从雾城回来之后，便筹划着去下一个地方，毕竟这是最开始首先计划去的地方。在等待的期间，想着，如果不去，会是如何，我曾考虑过这个问题。但是，依然如同女孩买包包男孩买电脑那样，如果不去，就总是惦记，而这种感觉，是非常不好的，它很容易会让人在未来错失太多。\n如果你真的问我此行有什么收获，我想，我也说不出个一二三四，毕竟，文字功底的水平摆在这，不够。\n被存满了的相机和手机，我回来第一件事情就将它们都清理出来，换个地方存着。\n也想着，如果有些想明白了，我想着拿那些素材可以用来做点什么，比如，剪一段视频。\n然而，暂时我没想明白，它仅仅还只是一个火花，我也不知道它能维持多久，有些东西，总都是有时效性的，毕竟。\n在通过某个十字路口的某一瞬间，我想我是不是又来到了第5年的黑暗时期，就如同突然转身发现身后深渊万丈，时间已过万重山，回不去；而眼前又深坑辽阔，遍布荆棘，很难走。\n虽然现在，已远没有当初那么害怕了。\n给一纸简历，为获一丝兴趣；\n约一次面试，为破一丝幻象。\n稍近一步，将距离再拉近一些来观察，以便进一步做些了解。\n幻象，在看到文字之后面对文字所透露出来的明显与不那么明显的信息进行主观想象，并尝试以此建立一个人物场景画像。\n而在我们无数次的尝试之后，有了并不那么清晰的幻象。\n参与一次面试，都当是为把这幻象，打破它，然后，又重新建立，觉得好，就要了它，觉得不行，就放弃它。\n而参与一次旅行，这感受与过程，几乎一模一样。\n我曾不知道我将会去到哪里，就如同抵达目的地之后才去找寻夜晚住宿。惊喜的事情总是只能是在事后才会发现原来刚刚经历的过程是真的如此地美好，而失望却可以在抵达目的地之前便可感知事情的不靠谱。\n现在也不可预知我将要去哪里，希望与恐惧并行，意外和失望总应也是不可避免。\n或许我可以期望如同在岛上那样的境况，也来点意外惊喜吧！\n我在考虑很久和测试了许多次之后，我最终决定了将我的简历换一种方式来处理，启用Markdown格式撰写简历文件，使用GitHub来帮我存储和公开在线展示简历内容，以及利用git技术和git flow工作流程进行文件版本控制。\n点击下方「阅读原文」 即可在GitHub查阅我的简历\n",
        "date": 1479859200,
        "objectID": "f67414d303fd6a2fb096b7fd4b601af7",
        "relpermalink": "/post/2016-11-23-%E9%9D%A2%E8%AF%95%E4%B8%8E%E6%97%85%E8%A1%8C%E4%B8%80%E6%A0%B7%E7%A8%8D%E8%BF%91%E4%B8%80%E6%AD%A5%E6%89%93%E7%A0%B4%E4%B8%80%E4%B8%9D%E5%B9%BB%E8%B1%A1/",
        "section": "post",
        "title": "面试与旅行一样，稍近一步打破一丝幻象",
        "size": 2024
    },
    {
        "content": "我以为秋天的来临会使得自己变得更加的喜悦，然而，它并没有。\n我想去外面走走，骑车或者是走路都可以，可是并没有。\n有更吸引人的东西在招摇着。\n如果说一个人到底能跟自己在一个相对封闭的空间里一直地持续呆上多久的时间，我想，这并不能得到一个明确的结果。\n就像，那几年前的秋天一样，我一个人，在漫山遍野地走，走过了白日，又走向了黑夜，山里的黑夜并不是完全的地寂静。\n那是，十几年前的秋天了。\n现在，不再需要担心会有黑夜的惧怕感了，毕竟，如果就自然地沉睡去，即时不关灯也是可以的。\n可是在山里的黑夜，不能睡。\n我为什么会在山野里晃荡呢？\n这是我一直没能搞明白的一件事情。\n即时远处能看到灯火通明，能听到狗吠鸡鸣，可并不会有人能知道，在一眼扫过的某一大片黑色的空间里，还有一个人的存在吧。\n黑夜的山，望过去总是有点惊悚吓人。\n灯火通明的黑夜里，我更加难以入睡了。\n我始终认为一个行为是有一定的来由的，比如，说出一句话，或者，做出一个动作。\n即时是无意识，那也就是仅仅是自己所认为的无意识吧。\n总有一天，能被回想起来。\n这又会使得我，回忆起几年前的一些画面和情景。\n所以，记忆太好总是不是什么好事情。\n而我，逐渐地，在忘记一些事情。\n顺便地，也忘记了很多事情。\n比如，昨天提到过的那什么，我怎么就想不起来了呢……\n只是希望，将来……\n那又会是怎样的呢？\n我应该还会能想起现在的样子。\n希望。\n",
        "date": 1470614400,
        "objectID": "75110bb58581f80ec3700275828eed14",
        "relpermalink": "/post/2016-08-08-%E8%90%BD%E5%8F%B6%E4%B8%8D%E7%9F%A5%E7%A7%8B/",
        "section": "post",
        "title": "落叶不知秋",
        "size": 1252
    },
    {
        "content": "有时候想想，我们生活的空间也是足够恶劣的了。\n办公室，工地开了一年多，duanduanduan地搞了半年多，dingdingding地搞了半年多，我又开始怀疑接下来的日子里，wuwuwu的节奏怕是难以逃离了。\n不通风，不透气，开窗嘈杂，关窗憋屈。\n唯一能使得我能够静心地坐着的缘故是，冷冷地。\n每日早晨，到公司第一件事情是降温，降体温，体表温度。\n等汗渍干去，等头脑冰凉。\n才得以开始干活和思考事情。\n还好这也习惯了，花去时间并不需要很多，顺便也就是吃个早餐的时间。\n家里的空调效果出奇地好，一个字，新。\n虽然用了一年多了似乎，当然跟新的也相差不远。\n早些天，26度，鼻子有点塞。\n27.\n28.\n29.\n对头，刚刚好的样子，不冰，也不温。\n仅稍稍有点凉凉的。\n偶尔为了房间快速降温，跑去25，疯！\n没有空调是肯定写不出东西的，觉都睡不好，何况呢。\n那天车上听邻座的女孩说18度的被子，我深深的认为那肯定是空调要修一修补一补东西了。\n晚上我也依然会盖被子。\n这次我把字体调大了一个号，到了15px，段距1.3，你觉得如何。要是能会点css就好了……\n",
        "date": 1467158400,
        "objectID": "a3c0c82333c632e8155a500994160fe9",
        "relpermalink": "/post/2016-06-29-%E6%88%91%E4%BB%AC%E5%AE%B6%E7%9A%84%E7%A9%BA%E8%B0%8329%E5%BA%A6/",
        "section": "post",
        "title": "我们家的空调29度",
        "size": 1024
    },
    {
        "content": "记得，早些时候去了乌镇。\n今天，想起来Keep一下。\n歇着，便又想起来木心美术馆的样子。\n干净，利落，简约，干练，唯美。\n我没能拥有华丽的词语储备，使得我无法能更加华丽丽地将它诉诸于你的脑海里。\n所以恐怕还是需要你自己去研究一番，才能有自己的印象了。\n我本是在乌镇，元宵刚过的乌镇并没有太多的游人。听民宿的老板说活，前些日子，这里人山人海，好几万人。我想，我来的时候也是刚好了，我的确是无法忍受人山人海的画面感。\n这小镇的地方倒是并不大，但考虑到步行并不合适，所以就试着去租了自行车。\n如果这个时候，不会骑车，倒不是有啥不可的，或许还有其它更好的方式也不一定。\n当然，我会。\n乌镇的自行车租用比深圳要高级，微信就能租车，打开微信，关注，注册，交押金，取车，piapiapia地就奔上马路嗨去了。\n南街区，未开发。\n有开发的东西街区，都设好了检票口，人们都说东区不要去了，晚上直接去西区就好，它们都一样的。\n我没去东区里面，我在外面兜圈，听了戏，拍了视频。\n又遇见可以邮寄明信片的店家，上了些年纪的老叔叔，但是做起事情依然干练，意外豪华地选了几套，随机抽了几张写上字，寄出，其它的，叔叔都给盖了邮戳，手起戳落，利索。\n天色暗，扔进邮筒。\n到西区外面还了车，往西区里面走了去。\n买票。\n虽然好贵的。\n有船，没坐。\n走路进去，乌镇剧院。\n而后就看到了木心美术馆，这是个意外。\n我没想到它在这里，并未作事先的功课，所以不知道它在这里。\n遇到了，就是意外的惊喜，不过，得额外买票，也就买了吧，虽然有点怪怪的。\n这就是特么的惊喜。\n就此打住，不细说了。\n要乌镇的明信片可以找我，要不要收钱，视君心情。\n题图：乌镇剧院\n",
        "date": 1467072000,
        "objectID": "8d5ac2c848803d82a24043a00803a751",
        "relpermalink": "/post/2016-06-28-%E9%81%87%E8%A7%81%E6%9C%A8%E5%BF%83%E7%BE%8E%E6%9C%AF%E9%A6%86%E6%98%AF%E4%B8%AA%E6%84%8F%E5%A4%96/",
        "section": "post",
        "title": "遇见木心美术馆是个意外",
        "size": 1480
    },
    {
        "content": " collections.OrderedDict.fromkeys(list).keys() 在 Python 中，有时候有需要用到保留原始顺序而又能去掉重复的列表。\n而在 Python 自身的基本数据结构里面，给 list 去除重复可以用 set(list) 来进行操作而得到一个没有重复的set集合，但是这样也就把list元素原有的先后出现的顺序而被打乱了，打的乱七八糟的。\n会写 Python 的也可能会找到很多的解决办法，有容易的有复杂的有高级的。\n我的方法 在 Python 的 collections 包里面有个数据结构叫 OrderedDict，有序字典。\n字典的 key 有个特性是不会重复，Python 默认的字典的 key 也是无序的，这是由它本身的特性决定的，但是有人结合了 list 的特性，制造了这个有序字典的数据结构，它输出的 key 和 value 都是有序的。\n所以利用它的这些特性，这样理论上就会很容易就能得到有序的没有重复的 list 了。\nimport collections datalist = [&#39;1&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;, &#39;2&#39;, &#39;4&#39;] newlist = collections.OrderedDict.fromkeys(datalist).keys() print(newlist) [&#39;1&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;] 这样就能得到一个保留元素第一次出现的先后顺序又去除了重复元素的list了。一般用来给人查看或者是显示操作结果的时候，是对人很友好的。\n好了，这里其实是第一次正经测试 Markdown 语法来写文章的内容，目前看起来貌似还蛮美观的吭。\n",
        "date": 1467072000,
        "objectID": "dda73aded3d48bc9e195bda3b56d735c",
        "relpermalink": "/python/2016-06-28-%E7%BB%99%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%8D%B4%E5%8F%88%E8%A6%81%E4%BF%9D%E7%95%99%E9%A1%BA%E5%BA%8F/",
        "section": "python",
        "title": "给一个列表去重复却又要保留顺序",
        "size": 1660
    }
]